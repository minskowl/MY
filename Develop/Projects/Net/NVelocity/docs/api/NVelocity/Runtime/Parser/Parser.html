<html>
  <head>
    <META http-equiv="Content-Type" content="text/html; charset=utf-8">
    <link rel="stylesheet" type="text/css" href="..\..\..\JavaDoc.css">
  </head>
  <body>
    <table class="nav">
      <tr>
        <td class="nav1" colspan="2">
          <table cellspacing="3">
            <tr>
              <td>
                <a href="..\..\..\overview-summary.html"> Overview </a>
              </td>
              <td>
                <a href="namespace-summary.html">Namespace</a> </td>
              <td class="nav1sel"> Type </td>
              <td>Use </td>
              <td>Tree </td>
              <td>Deprecated </td>
              <td>Index </td>
              <td>Help </td>
            </tr>
          </table>
        </td>
        <td class="logo" rowspan="2">.NET Framework</td>
      </tr>
      <tr class="nav2">
        <td>PREV TYPE    NEXT TYPE</td>
        <td>FRAMES    NO FRAMES</td>
      </tr>
      <tr class="nav2">
        <td>SUMMARY: INNER | <a href="#field-summary">FIELD</a> | <a href="#constructor-summary">CONST</a> | <a href="#property-summary">PROP</a> | <a href="#method-summary">METHOD</a> | OP | EVENT</td>
        <td>DETAIL: <a href="#field-detail">FIELD</a> | <a href="#constructor-detail">CONST</a> | <a href="#property-detail">PROP</a> | <a href="#method-detail">METHOD</a> | OP | EVENT</td>
      </tr>
    </table>
    <hr>
    <h2>
      <span class="namespaceName">NVelocity.Runtime.Parser</span>
      <br>
      <span class="className">Class Parser</span>
    </h2>
    <p> This class is responsible for parsing a Velocity
            template. This class was generated by JavaCC using
            the JJTree extension to produce an Abstract
            Syntax Tree (AST) of the template.
            
            Please look at the Parser.jjt file which is
            what controls the generation of this class.
            </p>
    <a name="field-summary">
    </a>
    <table class="table" cellspacing="0">
      <thead>
        <tr>
          <th colspan="2">Field Summary</th>
        </tr>
      </thead>
      <tr>
        <td class="fieldType" valign="top">NVelocity.Runtime.Parser.Token</td>
        <td class="field">
          <a href="#NVelocity.Runtime.Parser.Parser.jj_nt">jj_nt</a>
        </td>
      </tr>
      <tr>
        <td class="fieldType" valign="top">bool</td>
        <td class="field">
          <a href="#NVelocity.Runtime.Parser.Parser.lookingAhead">lookingAhead</a>
        </td>
      </tr>
      <tr>
        <td class="fieldType" valign="top">NVelocity.Runtime.Parser.Token</td>
        <td class="field">
          <a href="#NVelocity.Runtime.Parser.Parser.token">token</a>
        </td>
      </tr>
      <tr>
        <td class="fieldType" valign="top">NVelocity.Runtime.Parser.ParserTokenManager</td>
        <td class="field">
          <a href="#NVelocity.Runtime.Parser.Parser.token_source">token_source</a>
        </td>
      </tr>
    </table>
    <br>
    <a name="constructor-summary">
    </a>
    <table class="table" cellspacing="0">
      <thead>
        <tr>
          <th colspan="2">Constructor Summary</th>
        </tr>
      </thead>
      <tr>
        <td class="constructor" valign="top">
          <a href="#NVelocity.Runtime.Parser.Parser.#ctor(NVelocity.Runtime.RuntimeServices)">Parser</a>(NVelocity.Runtime.RuntimeServices rs)<br>         This constructor was added to allow the re-use of parsers.
            The normal constructor takes a single argument which
            an InputStream. This simply creates a re-usable parser
            object, we satisfy the requirement of an InputStream
            by using a newline character as an input stream.
            </td>
      </tr>
      <tr>
        <td class="constructor" valign="top">
          <a href="#NVelocity.Runtime.Parser.Parser.#ctor(NVelocity.Runtime.Parser.CharStream)">Parser</a>(NVelocity.Runtime.Parser.CharStream stream)</td>
      </tr>
      <tr>
        <td class="constructor" valign="top">
          <a href="#NVelocity.Runtime.Parser.Parser.#ctor(NVelocity.Runtime.Parser.ParserTokenManager)">Parser</a>(NVelocity.Runtime.Parser.ParserTokenManager tm)</td>
      </tr>
    </table>
    <br>
    <a name="property-summary">
    </a>
    <table class="table" cellspacing="0">
      <thead>
        <tr>
          <th colspan="2">Property Summary</th>
        </tr>
      </thead>
      <tr>
        <td class="propertyType" valign="top">System.Collections.Hashtable</td>
        <td class="property">
          <a href="#NVelocity.Runtime.Parser.Parser.Directives">Directives</a>
        </td>
      </tr>
      <tr>
        <td class="propertyType" valign="top">NVelocity.Runtime.Parser.Token</td>
        <td class="property">
          <a href="#NVelocity.Runtime.Parser.Parser.NextToken">NextToken</a>
        </td>
      </tr>
    </table>
    <br>
    <a name="method-summary">
    </a>
    <table class="table" cellspacing="0">
      <thead>
        <tr>
          <th colspan="2">Method Summary</th>
        </tr>
      </thead>
      <tr>
        <td class="returnType" valign="top">void</td>
        <td class="method">
          <a href="#NVelocity.Runtime.Parser.Parser.AdditiveExpression">AdditiveExpression</a>()</td>
      </tr>
      <tr>
        <td class="returnType" valign="top">void</td>
        <td class="method">
          <a href="#NVelocity.Runtime.Parser.Parser.Assignment">Assignment</a>()</td>
      </tr>
      <tr>
        <td class="returnType" valign="top">void</td>
        <td class="method">
          <a href="#NVelocity.Runtime.Parser.Parser.Comment">Comment</a>()</td>
      </tr>
      <tr>
        <td class="returnType" valign="top">void</td>
        <td class="method">
          <a href="#NVelocity.Runtime.Parser.Parser.ConditionalAndExpression">ConditionalAndExpression</a>()</td>
      </tr>
      <tr>
        <td class="returnType" valign="top">void</td>
        <td class="method">
          <a href="#NVelocity.Runtime.Parser.Parser.ConditionalOrExpression">ConditionalOrExpression</a>()</td>
      </tr>
      <tr>
        <td class="returnType" valign="top">NVelocity.Runtime.Parser.Node.SimpleNode</td>
        <td class="method">
          <a href="#NVelocity.Runtime.Parser.Parser.Directive">Directive</a>()<br>           Supports the Pluggable Directives
            #foo( arg+ )
            </td>
      </tr>
      <tr>
        <td class="returnType" valign="top">void</td>
        <td class="method">
          <a href="#NVelocity.Runtime.Parser.Parser.DirectiveArg">DirectiveArg</a>()<br>           Supports the arguments for the Pluggable Directives
            We add whitespace in here as a token so the VMs can
            easily reconstruct a macro body from the token stream
            See Directive()
            </td>
      </tr>
      <tr>
        <td class="returnType" valign="top">void</td>
        <td class="method">
          <a href="#NVelocity.Runtime.Parser.Parser.disable_tracing">disable_tracing</a>()</td>
      </tr>
      <tr>
        <td class="returnType" valign="top">void</td>
        <td class="method">
          <a href="#NVelocity.Runtime.Parser.Parser.ElseIfStatement">ElseIfStatement</a>()</td>
      </tr>
      <tr>
        <td class="returnType" valign="top">void</td>
        <td class="method">
          <a href="#NVelocity.Runtime.Parser.Parser.ElseStatement">ElseStatement</a>()</td>
      </tr>
      <tr>
        <td class="returnType" valign="top">void</td>
        <td class="method">
          <a href="#NVelocity.Runtime.Parser.Parser.enable_tracing">enable_tracing</a>()</td>
      </tr>
      <tr>
        <td class="returnType" valign="top">void</td>
        <td class="method">
          <a href="#NVelocity.Runtime.Parser.Parser.EqualityExpression">EqualityExpression</a>()</td>
      </tr>
      <tr>
        <td class="returnType" valign="top">void</td>
        <td class="method">
          <a href="#NVelocity.Runtime.Parser.Parser.Escape">Escape</a>()</td>
      </tr>
      <tr>
        <td class="returnType" valign="top">void</td>
        <td class="method">
          <a href="#NVelocity.Runtime.Parser.Parser.EscapedDirective">EscapedDirective</a>()<br>          used to separate the notion of a valid directive that has been
            escaped, versus something that looks like a directive and
            is just schmoo.  This is important to do as a separate production
            that creates a node, because we want this, in either case, to stop
            the further parsing of the Directive() tree.
            </td>
      </tr>
      <tr>
        <td class="returnType" valign="top">void</td>
        <td class="method">
          <a href="#NVelocity.Runtime.Parser.Parser.Expression">Expression</a>()</td>
      </tr>
      <tr>
        <td class="returnType" valign="top">void</td>
        <td class="method">
          <a href="#NVelocity.Runtime.Parser.Parser.False">False</a>()</td>
      </tr>
      <tr>
        <td class="returnType" valign="top">NVelocity.Runtime.Parser.ParseException</td>
        <td class="method">
          <a href="#NVelocity.Runtime.Parser.Parser.generateParseException">generateParseException</a>()</td>
      </tr>
      <tr>
        <td class="returnType" valign="top">NVelocity.Runtime.Directive.Directive</td>
        <td class="method">
          <a href="#NVelocity.Runtime.Parser.Parser.getDirective(System.String)">getDirective</a>(string directive)<br>          This method gets a Directive from the directives Hashtable
            </td>
      </tr>
      <tr>
        <td class="returnType" valign="top">NVelocity.Runtime.Parser.Token</td>
        <td class="method">
          <a href="#NVelocity.Runtime.Parser.Parser.getToken(System.Int32)">getToken</a>(int index)</td>
      </tr>
      <tr>
        <td class="returnType" valign="top">void</td>
        <td class="method">
          <a href="#NVelocity.Runtime.Parser.Parser.Identifier">Identifier</a>()<br>         This method corresponds to variable
            references in Velocity templates.
            The following are examples of variable
            references that may be found in a
            template:
            *
            $foo
            $bar
            *
            </td>
      </tr>
      <tr>
        <td class="returnType" valign="top">void</td>
        <td class="method">
          <a href="#NVelocity.Runtime.Parser.Parser.IfStatement">IfStatement</a>()</td>
      </tr>
      <tr>
        <td class="returnType" valign="top">void</td>
        <td class="method">
          <a href="#NVelocity.Runtime.Parser.Parser.IntegerRange">IntegerRange</a>()<br>          supports the [n..m] vector generator for use in
            the #foreach() to generate measured ranges w/o
            needing explicit support from the app/servlet
            </td>
      </tr>
      <tr>
        <td class="returnType" valign="top">bool</td>
        <td class="method">
          <a href="#NVelocity.Runtime.Parser.Parser.isDirective(System.String)">isDirective</a>(string directive)<br>          This method finds out of the directive exists in the directives
            Hashtable.
            </td>
      </tr>
      <tr>
        <td class="returnType" valign="top">void</td>
        <td class="method">
          <a href="#NVelocity.Runtime.Parser.Parser.Method">Method</a>()<br>         This method has yet to be fully implemented
            but will allow arbitrarily nested method
            calls
            </td>
      </tr>
      <tr>
        <td class="returnType" valign="top">void</td>
        <td class="method">
          <a href="#NVelocity.Runtime.Parser.Parser.MultiplicativeExpression">MultiplicativeExpression</a>()</td>
      </tr>
      <tr>
        <td class="returnType" valign="top">void</td>
        <td class="method">
          <a href="#NVelocity.Runtime.Parser.Parser.NumberLiteral">NumberLiteral</a>()</td>
      </tr>
      <tr>
        <td class="returnType" valign="top">void</td>
        <td class="method">
          <a href="#NVelocity.Runtime.Parser.Parser.ObjectArray">ObjectArray</a>()</td>
      </tr>
      <tr>
        <td class="returnType" valign="top">void</td>
        <td class="method">
          <a href="#NVelocity.Runtime.Parser.Parser.Parameter">Parameter</a>()<br>         This method has yet to be fully implemented
            but will allow arbitrarily nested method
            calls
            </td>
      </tr>
      <tr>
        <td class="returnType" valign="top">NVelocity.Runtime.Parser.Node.SimpleNode</td>
        <td class="method">
          <a href="#NVelocity.Runtime.Parser.Parser.parse(System.IO.TextReader,System.String)">parse</a>(System.IO.TextReader reader, string templateName)<br>         This was also added to allow parsers to be
            re-usable. Normal JavaCC use entails passing an
            input stream to the constructor and the parsing
            process is carried out once. We want to be able
            to re-use parsers: we do this by adding this
            method and re-initializing the lexer with
            the new stream that we want parsed.
            </td>
      </tr>
      <tr>
        <td class="returnType" valign="top">void</td>
        <td class="method">
          <a href="#NVelocity.Runtime.Parser.Parser.PrimaryExpression">PrimaryExpression</a>()</td>
      </tr>
      <tr>
        <td class="returnType" valign="top">NVelocity.Runtime.Parser.Node.SimpleNode</td>
        <td class="method">
          <a href="#NVelocity.Runtime.Parser.Parser.process">process</a>()<br>         This method is what starts the whole parsing
            process. After the parsing is complete and
            the template has been turned into an AST,
            this method returns the root of AST which
            can subsequently be traversed by a visitor
            which implements the ParserVisitor interface
            which is generated automatically by JavaCC
            </td>
      </tr>
      <tr>
        <td class="returnType" valign="top">void</td>
        <td class="method">
          <a href="#NVelocity.Runtime.Parser.Parser.Reference">Reference</a>()</td>
      </tr>
      <tr>
        <td class="returnType" valign="top">void</td>
        <td class="method">
          <a href="#NVelocity.Runtime.Parser.Parser.ReInit(NVelocity.Runtime.Parser.ParserTokenManager)">ReInit</a>(NVelocity.Runtime.Parser.ParserTokenManager tm)</td>
      </tr>
      <tr>
        <td class="returnType" valign="top">void</td>
        <td class="method">
          <a href="#NVelocity.Runtime.Parser.Parser.ReInit(NVelocity.Runtime.Parser.CharStream)">ReInit</a>(NVelocity.Runtime.Parser.CharStream stream)</td>
      </tr>
      <tr>
        <td class="returnType" valign="top">void</td>
        <td class="method">
          <a href="#NVelocity.Runtime.Parser.Parser.RelationalExpression">RelationalExpression</a>()</td>
      </tr>
      <tr>
        <td class="returnType" valign="top">void</td>
        <td class="method">
          <a href="#NVelocity.Runtime.Parser.Parser.SetDirective">SetDirective</a>()<br>          Currently support both types of set :
            #set( expr )
            #set expr
            </td>
      </tr>
      <tr>
        <td class="returnType" valign="top">void</td>
        <td class="method">
          <a href="#NVelocity.Runtime.Parser.Parser.Statement">Statement</a>()<br>         These are the types of statements that
            are acceptable in Velocity templates.
            </td>
      </tr>
      <tr>
        <td class="returnType" valign="top">void</td>
        <td class="method">
          <a href="#NVelocity.Runtime.Parser.Parser.StopStatement">StopStatement</a>()<br>         This method corresponds to the #stop
            directive which just simulates and EOF
            so that parsing stops. The #stop directive
            is useful for end-user debugging
            purposes.
            </td>
      </tr>
      <tr>
        <td class="returnType" valign="top">void</td>
        <td class="method">
          <a href="#NVelocity.Runtime.Parser.Parser.StringLiteral">StringLiteral</a>()</td>
      </tr>
      <tr>
        <td class="returnType" valign="top">void</td>
        <td class="method">
          <a href="#NVelocity.Runtime.Parser.Parser.Text">Text</a>()<br>         This method is responsible for allowing
            all non-grammar text to pass through
            unscathed.
            </td>
      </tr>
      <tr>
        <td class="returnType" valign="top">void</td>
        <td class="method">
          <a href="#NVelocity.Runtime.Parser.Parser.True">True</a>()</td>
      </tr>
      <tr>
        <td class="returnType" valign="top">void</td>
        <td class="method">
          <a href="#NVelocity.Runtime.Parser.Parser.UnaryExpression">UnaryExpression</a>()</td>
      </tr>
      <tr>
        <td class="returnType" valign="top">void</td>
        <td class="method">
          <a href="#NVelocity.Runtime.Parser.Parser.Word">Word</a>()</td>
      </tr>
    </table>
    <br>
    <table class="subtable" cellspacing="0">
      <thead>
        <tr>
          <th>Methods inherited from class System.Object</th>
        </tr>
      </thead>
      <tr>
        <td>
          <a href="..\..\..\NVelocity/Runtime/Parser/Parser/Equals(System.html#Object)">Equals</a>, <a href="..\..\..\NVelocity/Runtime/Parser/Parser.html#Finalize">Finalize</a>, <a href="..\..\..\NVelocity/Runtime/Parser/Parser.html#GetHashCode">GetHashCode</a>, <a href="..\..\..\NVelocity/Runtime/Parser/Parser.html#GetType">GetType</a>, <a href="..\..\..\NVelocity/Runtime/Parser/Parser.html#MemberwiseClone">MemberwiseClone</a>, <a href="..\..\..\NVelocity/Runtime/Parser/Parser.html#ToString">ToString</a></td>
      </tr>
    </table>
    <br>
    <a name="operator-summary">
    </a>
    <a name="event-summary">
    </a>
    <br>
    <a name="field-detail">
    </a>
    <table class="table" cellspacing="0">
      <thead>
        <tr>
          <th>Field Detail</th>
        </tr>
      </thead>
    </table>
    <a name="NVelocity.Runtime.Parser.Parser.jj_nt">
    </a>
    <h3>jj_nt</h3>
    <pre>public NVelocity.Runtime.Parser.Token <b>jj_nt</b></pre>
    <dl>
      <dd>
        <p>
        </p>
        <p>
        </p>
      </dd>
    </dl>
    <hr>
    <a name="NVelocity.Runtime.Parser.Parser.lookingAhead">
    </a>
    <h3>lookingAhead</h3>
    <pre>public bool <b>lookingAhead</b></pre>
    <dl>
      <dd>
        <p>
        </p>
        <p>
        </p>
      </dd>
    </dl>
    <hr>
    <a name="NVelocity.Runtime.Parser.Parser.token">
    </a>
    <h3>token</h3>
    <pre>public NVelocity.Runtime.Parser.Token <b>token</b></pre>
    <dl>
      <dd>
        <p>
        </p>
        <p>
        </p>
      </dd>
    </dl>
    <hr>
    <a name="NVelocity.Runtime.Parser.Parser.token_source">
    </a>
    <h3>token_source</h3>
    <pre>public NVelocity.Runtime.Parser.ParserTokenManager <b>token_source</b></pre>
    <dl>
      <dd>
        <p>
        </p>
        <p>
        </p>
      </dd>
    </dl>
    <a name="constructor-detail">
    </a>
    <table class="table" cellspacing="0">
      <thead>
        <tr>
          <th>Constructor Detail</th>
        </tr>
      </thead>
    </table>
    <a name="NVelocity.Runtime.Parser.Parser.#ctor(NVelocity.Runtime.RuntimeServices)">
    </a>
    <h3>Parser</h3>
    <pre>public Parser(NVelocity.Runtime.RuntimeServices rs)</pre>
    <dl>
      <dd>
        <p> This constructor was added to allow the re-use of parsers.
            The normal constructor takes a single argument which
            an InputStream. This simply creates a re-usable parser
            object, we satisfy the requirement of an InputStream
            by using a newline character as an input stream.
            </p>
        <p>
        </p>
      </dd>
    </dl>
    <hr>
    <a name="NVelocity.Runtime.Parser.Parser.#ctor(NVelocity.Runtime.Parser.CharStream)">
    </a>
    <h3>Parser</h3>
    <pre>public Parser(NVelocity.Runtime.Parser.CharStream stream)</pre>
    <dl>
      <dd>
        <p>
        </p>
        <p>
        </p>
      </dd>
    </dl>
    <hr>
    <a name="NVelocity.Runtime.Parser.Parser.#ctor(NVelocity.Runtime.Parser.ParserTokenManager)">
    </a>
    <h3>Parser</h3>
    <pre>public Parser(NVelocity.Runtime.Parser.ParserTokenManager tm)</pre>
    <dl>
      <dd>
        <p>
        </p>
        <p>
        </p>
      </dd>
    </dl>
    <a name="property-detail">
    </a>
    <table class="table" cellspacing="0">
      <thead>
        <tr>
          <th>Property Detail</th>
        </tr>
      </thead>
    </table>
    <a name="NVelocity.Runtime.Parser.Parser.Directives">
    </a>
    <h3>Directives</h3>
    <pre>public System.Collections.Hashtable Directives</pre>
    <dl>
      <dd>
        <p>
        </p>
        <p>
        </p>
      </dd>
    </dl>
    <hr>
    <a name="NVelocity.Runtime.Parser.Parser.NextToken">
    </a>
    <h3>NextToken</h3>
    <pre>public NVelocity.Runtime.Parser.Token NextToken</pre>
    <dl>
      <dd>
        <p>
        </p>
        <p>
        </p>
      </dd>
    </dl>
    <a name="method-detail">
    </a>
    <table class="table" cellspacing="0">
      <thead>
        <tr>
          <th>Method Detail</th>
        </tr>
      </thead>
    </table>
    <a name="NVelocity.Runtime.Parser.Parser.AdditiveExpression">
    </a>
    <h3>AdditiveExpression</h3>
    <pre>public void AdditiveExpression()</pre>
    <dl>
      <dd>
        <p>
        </p>
        <p>
        </p>
      </dd>
    </dl>
    <hr>
    <a name="NVelocity.Runtime.Parser.Parser.Assignment">
    </a>
    <h3>Assignment</h3>
    <pre>public void Assignment()</pre>
    <dl>
      <dd>
        <p>
        </p>
        <p>
        </p>
      </dd>
    </dl>
    <hr>
    <a name="NVelocity.Runtime.Parser.Parser.Comment">
    </a>
    <h3>Comment</h3>
    <pre>public void Comment()</pre>
    <dl>
      <dd>
        <p>
        </p>
        <p>
        </p>
      </dd>
    </dl>
    <hr>
    <a name="NVelocity.Runtime.Parser.Parser.ConditionalAndExpression">
    </a>
    <h3>ConditionalAndExpression</h3>
    <pre>public void ConditionalAndExpression()</pre>
    <dl>
      <dd>
        <p>
        </p>
        <p>
        </p>
      </dd>
    </dl>
    <hr>
    <a name="NVelocity.Runtime.Parser.Parser.ConditionalOrExpression">
    </a>
    <h3>ConditionalOrExpression</h3>
    <pre>public void ConditionalOrExpression()</pre>
    <dl>
      <dd>
        <p>
        </p>
        <p>
        </p>
      </dd>
    </dl>
    <hr>
    <a name="NVelocity.Runtime.Parser.Parser.Directive">
    </a>
    <h3>Directive</h3>
    <pre>public NVelocity.Runtime.Parser.Node.SimpleNode Directive()</pre>
    <dl>
      <dd>
        <p>   Supports the Pluggable Directives
            #foo( arg+ )
            </p>
        <p>
        </p>
      </dd>
    </dl>
    <hr>
    <a name="NVelocity.Runtime.Parser.Parser.DirectiveArg">
    </a>
    <h3>DirectiveArg</h3>
    <pre>public void DirectiveArg()</pre>
    <dl>
      <dd>
        <p>   Supports the arguments for the Pluggable Directives
            We add whitespace in here as a token so the VMs can
            easily reconstruct a macro body from the token stream
            See Directive()
            </p>
        <p>
        </p>
      </dd>
    </dl>
    <hr>
    <a name="NVelocity.Runtime.Parser.Parser.disable_tracing">
    </a>
    <h3>disable_tracing</h3>
    <pre>public void disable_tracing()</pre>
    <dl>
      <dd>
        <p>
        </p>
        <p>
        </p>
      </dd>
    </dl>
    <hr>
    <a name="NVelocity.Runtime.Parser.Parser.ElseIfStatement">
    </a>
    <h3>ElseIfStatement</h3>
    <pre>public void ElseIfStatement()</pre>
    <dl>
      <dd>
        <p>
        </p>
        <p>
        </p>
      </dd>
    </dl>
    <hr>
    <a name="NVelocity.Runtime.Parser.Parser.ElseStatement">
    </a>
    <h3>ElseStatement</h3>
    <pre>public void ElseStatement()</pre>
    <dl>
      <dd>
        <p>
        </p>
        <p>
        </p>
      </dd>
    </dl>
    <hr>
    <a name="NVelocity.Runtime.Parser.Parser.enable_tracing">
    </a>
    <h3>enable_tracing</h3>
    <pre>public void enable_tracing()</pre>
    <dl>
      <dd>
        <p>
        </p>
        <p>
        </p>
      </dd>
    </dl>
    <hr>
    <a name="NVelocity.Runtime.Parser.Parser.EqualityExpression">
    </a>
    <h3>EqualityExpression</h3>
    <pre>public void EqualityExpression()</pre>
    <dl>
      <dd>
        <p>
        </p>
        <p>
        </p>
      </dd>
    </dl>
    <hr>
    <a name="NVelocity.Runtime.Parser.Parser.Escape">
    </a>
    <h3>Escape</h3>
    <pre>public void Escape()</pre>
    <dl>
      <dd>
        <p>
        </p>
        <p>
        </p>
      </dd>
    </dl>
    <hr>
    <a name="NVelocity.Runtime.Parser.Parser.EscapedDirective">
    </a>
    <h3>EscapedDirective</h3>
    <pre>public void EscapedDirective()</pre>
    <dl>
      <dd>
        <p>  used to separate the notion of a valid directive that has been
            escaped, versus something that looks like a directive and
            is just schmoo.  This is important to do as a separate production
            that creates a node, because we want this, in either case, to stop
            the further parsing of the Directive() tree.
            </p>
        <p>
        </p>
      </dd>
    </dl>
    <hr>
    <a name="NVelocity.Runtime.Parser.Parser.Expression">
    </a>
    <h3>Expression</h3>
    <pre>public void Expression()</pre>
    <dl>
      <dd>
        <p>
        </p>
        <p>
        </p>
      </dd>
    </dl>
    <hr>
    <a name="NVelocity.Runtime.Parser.Parser.False">
    </a>
    <h3>False</h3>
    <pre>public void False()</pre>
    <dl>
      <dd>
        <p>
        </p>
        <p>
        </p>
      </dd>
    </dl>
    <hr>
    <a name="NVelocity.Runtime.Parser.Parser.generateParseException">
    </a>
    <h3>generateParseException</h3>
    <pre>public NVelocity.Runtime.Parser.ParseException generateParseException()</pre>
    <dl>
      <dd>
        <p>
        </p>
        <p>
        </p>
      </dd>
    </dl>
    <hr>
    <a name="NVelocity.Runtime.Parser.Parser.getDirective(System.String)">
    </a>
    <h3>getDirective</h3>
    <pre>public NVelocity.Runtime.Directive.Directive getDirective(string directive)</pre>
    <dl>
      <dd>
        <p>  This method gets a Directive from the directives Hashtable
            </p>
        <p>
        </p>
      </dd>
    </dl>
    <hr>
    <a name="NVelocity.Runtime.Parser.Parser.getToken(System.Int32)">
    </a>
    <h3>getToken</h3>
    <pre>public NVelocity.Runtime.Parser.Token getToken(int index)</pre>
    <dl>
      <dd>
        <p>
        </p>
        <p>
        </p>
      </dd>
    </dl>
    <hr>
    <a name="NVelocity.Runtime.Parser.Parser.Identifier">
    </a>
    <h3>Identifier</h3>
    <pre>public void Identifier()</pre>
    <dl>
      <dd>
        <p> This method corresponds to variable
            references in Velocity templates.
            The following are examples of variable
            references that may be found in a
            template:
            *
            $foo
            $bar
            *
            </p>
        <p>
        </p>
      </dd>
    </dl>
    <hr>
    <a name="NVelocity.Runtime.Parser.Parser.IfStatement">
    </a>
    <h3>IfStatement</h3>
    <pre>public void IfStatement()</pre>
    <dl>
      <dd>
        <p>
        </p>
        <p>
        </p>
      </dd>
    </dl>
    <hr>
    <a name="NVelocity.Runtime.Parser.Parser.IntegerRange">
    </a>
    <h3>IntegerRange</h3>
    <pre>public void IntegerRange()</pre>
    <dl>
      <dd>
        <p>  supports the [n..m] vector generator for use in
            the #foreach() to generate measured ranges w/o
            needing explicit support from the app/servlet
            </p>
        <p>
        </p>
      </dd>
    </dl>
    <hr>
    <a name="NVelocity.Runtime.Parser.Parser.isDirective(System.String)">
    </a>
    <h3>isDirective</h3>
    <pre>public bool isDirective(string directive)</pre>
    <dl>
      <dd>
        <p>  This method finds out of the directive exists in the directives
            Hashtable.
            </p>
        <p>
        </p>
      </dd>
    </dl>
    <hr>
    <a name="NVelocity.Runtime.Parser.Parser.Method">
    </a>
    <h3>Method</h3>
    <pre>public void Method()</pre>
    <dl>
      <dd>
        <p> This method has yet to be fully implemented
            but will allow arbitrarily nested method
            calls
            </p>
        <p>
        </p>
      </dd>
    </dl>
    <hr>
    <a name="NVelocity.Runtime.Parser.Parser.MultiplicativeExpression">
    </a>
    <h3>MultiplicativeExpression</h3>
    <pre>public void MultiplicativeExpression()</pre>
    <dl>
      <dd>
        <p>
        </p>
        <p>
        </p>
      </dd>
    </dl>
    <hr>
    <a name="NVelocity.Runtime.Parser.Parser.NumberLiteral">
    </a>
    <h3>NumberLiteral</h3>
    <pre>public void NumberLiteral()</pre>
    <dl>
      <dd>
        <p>
        </p>
        <p>
        </p>
      </dd>
    </dl>
    <hr>
    <a name="NVelocity.Runtime.Parser.Parser.ObjectArray">
    </a>
    <h3>ObjectArray</h3>
    <pre>public void ObjectArray()</pre>
    <dl>
      <dd>
        <p>
        </p>
        <p>
        </p>
      </dd>
    </dl>
    <hr>
    <a name="NVelocity.Runtime.Parser.Parser.Parameter">
    </a>
    <h3>Parameter</h3>
    <pre>public void Parameter()</pre>
    <dl>
      <dd>
        <p> This method has yet to be fully implemented
            but will allow arbitrarily nested method
            calls
            </p>
        <p>
        </p>
      </dd>
    </dl>
    <hr>
    <a name="NVelocity.Runtime.Parser.Parser.parse(System.IO.TextReader,System.String)">
    </a>
    <h3>parse</h3>
    <pre>public NVelocity.Runtime.Parser.Node.SimpleNode parse(System.IO.TextReader reader,
                                                      string templateName)</pre>
    <dl>
      <dd>
        <p> This was also added to allow parsers to be
            re-usable. Normal JavaCC use entails passing an
            input stream to the constructor and the parsing
            process is carried out once. We want to be able
            to re-use parsers: we do this by adding this
            method and re-initializing the lexer with
            the new stream that we want parsed.
            </p>
        <p>
        </p>
      </dd>
    </dl>
    <hr>
    <a name="NVelocity.Runtime.Parser.Parser.PrimaryExpression">
    </a>
    <h3>PrimaryExpression</h3>
    <pre>public void PrimaryExpression()</pre>
    <dl>
      <dd>
        <p>
        </p>
        <p>
        </p>
      </dd>
    </dl>
    <hr>
    <a name="NVelocity.Runtime.Parser.Parser.process">
    </a>
    <h3>process</h3>
    <pre>public NVelocity.Runtime.Parser.Node.SimpleNode process()</pre>
    <dl>
      <dd>
        <p> This method is what starts the whole parsing
            process. After the parsing is complete and
            the template has been turned into an AST,
            this method returns the root of AST which
            can subsequently be traversed by a visitor
            which implements the ParserVisitor interface
            which is generated automatically by JavaCC
            </p>
        <p>
        </p>
      </dd>
    </dl>
    <hr>
    <a name="NVelocity.Runtime.Parser.Parser.Reference">
    </a>
    <h3>Reference</h3>
    <pre>public void Reference()</pre>
    <dl>
      <dd>
        <p>
        </p>
        <p>
        </p>
      </dd>
    </dl>
    <hr>
    <a name="NVelocity.Runtime.Parser.Parser.ReInit(NVelocity.Runtime.Parser.ParserTokenManager)">
    </a>
    <h3>ReInit</h3>
    <pre>public void ReInit(NVelocity.Runtime.Parser.ParserTokenManager tm)</pre>
    <dl>
      <dd>
        <p>
        </p>
        <p>
        </p>
      </dd>
    </dl>
    <hr>
    <a name="NVelocity.Runtime.Parser.Parser.ReInit(NVelocity.Runtime.Parser.CharStream)">
    </a>
    <h3>ReInit</h3>
    <pre>public void ReInit(NVelocity.Runtime.Parser.CharStream stream)</pre>
    <dl>
      <dd>
        <p>
        </p>
        <p>
        </p>
      </dd>
    </dl>
    <hr>
    <a name="NVelocity.Runtime.Parser.Parser.RelationalExpression">
    </a>
    <h3>RelationalExpression</h3>
    <pre>public void RelationalExpression()</pre>
    <dl>
      <dd>
        <p>
        </p>
        <p>
        </p>
      </dd>
    </dl>
    <hr>
    <a name="NVelocity.Runtime.Parser.Parser.SetDirective">
    </a>
    <h3>SetDirective</h3>
    <pre>public void SetDirective()</pre>
    <dl>
      <dd>
        <p>  Currently support both types of set :
            #set( expr )
            #set expr
            </p>
        <p>
        </p>
      </dd>
    </dl>
    <hr>
    <a name="NVelocity.Runtime.Parser.Parser.Statement">
    </a>
    <h3>Statement</h3>
    <pre>public void Statement()</pre>
    <dl>
      <dd>
        <p> These are the types of statements that
            are acceptable in Velocity templates.
            </p>
        <p>
        </p>
      </dd>
    </dl>
    <hr>
    <a name="NVelocity.Runtime.Parser.Parser.StopStatement">
    </a>
    <h3>StopStatement</h3>
    <pre>public void StopStatement()</pre>
    <dl>
      <dd>
        <p> This method corresponds to the #stop
            directive which just simulates and EOF
            so that parsing stops. The #stop directive
            is useful for end-user debugging
            purposes.
            </p>
        <p>
        </p>
      </dd>
    </dl>
    <hr>
    <a name="NVelocity.Runtime.Parser.Parser.StringLiteral">
    </a>
    <h3>StringLiteral</h3>
    <pre>public void StringLiteral()</pre>
    <dl>
      <dd>
        <p>
        </p>
        <p>
        </p>
      </dd>
    </dl>
    <hr>
    <a name="NVelocity.Runtime.Parser.Parser.Text">
    </a>
    <h3>Text</h3>
    <pre>public void Text()</pre>
    <dl>
      <dd>
        <p> This method is responsible for allowing
            all non-grammar text to pass through
            unscathed.
            </p>
        <p>
        </p>
      </dd>
    </dl>
    <hr>
    <a name="NVelocity.Runtime.Parser.Parser.True">
    </a>
    <h3>True</h3>
    <pre>public void True()</pre>
    <dl>
      <dd>
        <p>
        </p>
        <p>
        </p>
      </dd>
    </dl>
    <hr>
    <a name="NVelocity.Runtime.Parser.Parser.UnaryExpression">
    </a>
    <h3>UnaryExpression</h3>
    <pre>public void UnaryExpression()</pre>
    <dl>
      <dd>
        <p>
        </p>
        <p>
        </p>
      </dd>
    </dl>
    <hr>
    <a name="NVelocity.Runtime.Parser.Parser.Word">
    </a>
    <h3>Word</h3>
    <pre>public void Word()</pre>
    <dl>
      <dd>
        <p>
        </p>
        <p>
        </p>
      </dd>
    </dl>
    <a name="operator-detail">
    </a>
    <a name="event-detail">
    </a>
    <hr>
    <table class="nav">
      <tr>
        <td class="nav1" colspan="2">
          <table cellspacing="3">
            <tr>
              <td>
                <a href="..\..\..\overview-summary.html"> Overview </a>
              </td>
              <td>
                <a href="namespace-summary.html">Namespace</a> </td>
              <td class="nav1sel"> Type </td>
              <td>Use </td>
              <td>Tree </td>
              <td>Deprecated </td>
              <td>Index </td>
              <td>Help </td>
            </tr>
          </table>
        </td>
        <td class="logo" rowspan="2">.NET Framework</td>
      </tr>
      <tr class="nav2">
        <td>PREV TYPE    NEXT TYPE</td>
        <td>FRAMES    NO FRAMES</td>
      </tr>
      <tr class="nav2">
        <td>SUMMARY: INNER | <a href="#field-summary">FIELD</a> | <a href="#constructor-summary">CONST</a> | <a href="#property-summary">PROP</a> | <a href="#method-summary">METHOD</a> | OP | EVENT</td>
        <td>DETAIL: <a href="#field-detail">FIELD</a> | <a href="#constructor-detail">CONST</a> | <a href="#property-detail">PROP</a> | <a href="#method-detail">METHOD</a> | OP | EVENT</td>
      </tr>
    </table>
  </body>
</html>