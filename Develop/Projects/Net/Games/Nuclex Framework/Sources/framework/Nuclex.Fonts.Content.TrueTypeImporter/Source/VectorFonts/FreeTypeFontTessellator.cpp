#pragma region CPL License
/*
Nuclex Framework
Copyright (C) 2002-2009 Nuclex Development Labs

This library is free software; you can redistribute it and/or
modify it under the terms of the IBM Common Public License as
published by the IBM Corporation; either version 1.0 of the
License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
IBM Common Public License for more details.

You should have received a copy of the IBM Common Public
License along with this library
*/
#pragma endregion

#include "FreeTypeFontTessellator.h"

#define WIN32_LEAN_AND_MEAN
#define WIN32_EXTRALEAN
#include <windows.h>
#include <gl/glu.h>

// Declare GLUtesselator as an empty class to get rid of the linker warning (LNK4248)
class GLUtesselator {};

#include <vector>

using namespace std;

using namespace System::Collections::Generic;

using namespace Microsoft::Xna::Framework;

namespace Nuclex { namespace Fonts { namespace Content {

  // ------------------------------------------------------------------------------------------- //

  /// <summary>Vector of floating point value pairs</summary>
  typedef std::vector< std::pair<float, float> > FloatPairVector;

  /// <summary>Stores the vertex indices for a triangle</summary>
  struct Triangle {

    /// <summary>Initializes a new triangle</summary>
    /// <param name="firstVertexIndex">Index of the triangle's first vertex</param>
    /// <param name="secondVertexIndex">Index of the triangle's second vertex</param>
    /// <param name="thirdVertexIndex">Index of the triangle's third vertex</param>
    public: Triangle(int firstVertexIndex, int secondVertexIndex, int thirdVertexIndex) :
      FirstVertexIndex(firstVertexIndex),
      SecondVertexIndex(secondVertexIndex),
      ThirdVertexIndex(thirdVertexIndex) {}

    /// <summary>Index of the triangle's first vertex</summary>
    public: int FirstVertexIndex;
    /// <summary>Index of the triangle's second vertex</summary>
    public: int SecondVertexIndex;
    /// <summary>Index of the triangle's third vertex</summary>
    public: int ThirdVertexIndex;

  };

  /// <summary>Vector of triangles</summary>
  typedef std::vector<Triangle> TriangleVector;

  /// <summary>Vector of pointers to vertex indices</summary>
  typedef std::vector<int *> VertexIndices;
  
  /// <summary>Internal structure used to construct a tessellated character</summary>
  struct TessellationSet {

    /// <summary>Destroys a tessellation set</summary>
    public: ~TessellationSet() {
      for(
        VertexIndices::const_reverse_iterator vertexIndex = this->Indices.rbegin();
        vertexIndex != this->Indices.rend();
        ++vertexIndex
      ) {
        delete *vertexIndex;
      }
    }

    /// <summary>Initializes a new tessellation set</summary>
    public: TessellationSet() {}

    /// <summary>The character's vertices</summary>
    public: FloatPairVector Vertices;

    /// <summary>The triangles generated by the tessellator</summary>
    public: TriangleVector Triangles;

    /// <summary>Pointers to the numbers 0, 1, 2 and so on (really!)</summary>
    public: VertexIndices Indices;

    /// <summary>First index for an intermediate vertex</summary>
    /// <remarks>
    ///   Contains the center vertex index for a triangle fan and the index of
    ///   the older trailing vertex for a triangle strip. Stores the index of
    ///   the first vertex in a triangle list.
    /// </remarks>
    public: int IntermediateVertexIndex1;

    /// <summary>Second index for an intermediate vertex</summary>
    /// <remarks>
    ///   Stores the trailing vertex for a triangle fan and the newer trailing
    ///   vertex for a triangle strip. Stores the index of the second vertex
    ///   in a vertex list.
    /// </remarks>
    public: int IntermediateVertexIndex2;

    /// <summary>Type of primitives that the tessellator is outputting</summary>
    public: GLenum Type;

  }; // struct TessellationSet

  // ------------------------------------------------------------------------------------------- //

  namespace { // anonymous

    /// <summary>Starts a new primitive in the tessellation process</summary>
    /// <param name="type">Type of the primitives to be drawn</param>
    /// <param name="tessellationSetAddress">
    ///   TessellationSet in which to begin constructing a new polygon.
    /// </param>
    GLvoid CALLBACK tessBegin(GLenum type, void *tessellationSetAddress) {
      TessellationSet &tessellationSet = *static_cast<TessellationSet *>(tessellationSetAddress);

      tessellationSet.Type = type;
      tessellationSet.IntermediateVertexIndex1 = -1;
      tessellationSet.IntermediateVertexIndex2 = -1;
    }

  } // anonymous namespace

  // ------------------------------------------------------------------------------------------- //

  namespace { // anonymous

    /// <summary>Ends the current primitive in the tessellation process</summary>
    /// <param name="tessellationSetAddress">
    ///   TessellationSet in which to end the polygon currently in construction.
    /// </param>
    GLvoid CALLBACK tessEnd(void *tessellationSetAddress) {
      TessellationSet &tessellationSet = *static_cast<TessellationSet *>(tessellationSetAddress);
    }

  } // anonymous namespace

  // ------------------------------------------------------------------------------------------- //

  namespace { // anonymous

    /// <summary>Adds a vertex to the primitives currently being constructed</summary>
    /// <param name="vertexData">
    ///   Vertex user data; contains the required indices to indentify the corresponding
    ///   vertex in the character's stored contour.
    /// </param>
    /// <param name="tessellationSetAddress">
    ///   TessellationSet to which the vertex will be added
    /// </param>
    GLvoid CALLBACK tessVertex(void *vertexData, void *tessellationSetAddress) {
      TessellationSet &tessellationSet = *static_cast<TessellationSet *>(tessellationSetAddress);
      int vertexIndex = *static_cast<int *>(vertexData);

      switch(tessellationSet.Type) {

        // An ordinary list of triangles. Three indices describe a single triangle,
        // then another three complete indices are sent to describe the next triangle.
        case GL_TRIANGLES: {
          if(tessellationSet.IntermediateVertexIndex1 == -1) {
            tessellationSet.IntermediateVertexIndex1 = vertexIndex;
            tessellationSet.IntermediateVertexIndex2 = -1;
          } else if(tessellationSet.IntermediateVertexIndex2 == -1) {
            tessellationSet.IntermediateVertexIndex2 = vertexIndex;
          } else {
            tessellationSet.Triangles.push_back(
              Triangle(
                tessellationSet.IntermediateVertexIndex1,
                tessellationSet.IntermediateVertexIndex2,
                vertexIndex
              )
            );
            tessellationSet.IntermediateVertexIndex1 = -1;
          }
          
          break;
        }

        // A triangle strip which reuses the 2 lastmost vertex indices and only adds
        // one new vertex to produce another triangle. Due to the algorithm,
        // the triangles would alternate between clockwise vertices and
        // counter-clockwise vertices, which has to be worked around.
        case GL_TRIANGLE_STRIP: {
          if(tessellationSet.IntermediateVertexIndex1 == -1) {
            tessellationSet.IntermediateVertexIndex1 = vertexIndex;
          } else if(tessellationSet.IntermediateVertexIndex2 == -1) {
            tessellationSet.IntermediateVertexIndex2 = vertexIndex;
          } else {
            tessellationSet.Triangles.push_back(
              Triangle(
                tessellationSet.IntermediateVertexIndex1,
                tessellationSet.IntermediateVertexIndex2,
                vertexIndex
              )
            );
            tessellationSet.IntermediateVertexIndex1 = tessellationSet.IntermediateVertexIndex2;
            tessellationSet.IntermediateVertexIndex2 = vertexIndex;
          }

          break;
        }

        // Triangle fan where the first vertex index given stays put and is used
        // to form a triangles between the first vertex, the lastmost vertex and
        // the current vertex being processed.
        case GL_TRIANGLE_FAN: {
          if(tessellationSet.IntermediateVertexIndex1 == -1) {
            tessellationSet.IntermediateVertexIndex1 = vertexIndex;
          } else if(tessellationSet.IntermediateVertexIndex2 == -1) {
            tessellationSet.IntermediateVertexIndex2 = vertexIndex;
          } else {
            tessellationSet.Triangles.push_back(
              Triangle(
                tessellationSet.IntermediateVertexIndex1,
                tessellationSet.IntermediateVertexIndex2,
                vertexIndex
              )
            );
            tessellationSet.IntermediateVertexIndex2 = vertexIndex;
          }
            
          break;
        }
      }
    }

  } // anonymous namespace

  // ------------------------------------------------------------------------------------------- //

  namespace { // anonymous

    /// <summary>Creates a new supporting vertex for the tessellator</summary>
    /// <param name="coords">Coordinates at which to place the new vertex</param>
    /// <param name="vertexData">
    ///   Vertex user data for up to 4 vertices that are being connected
    ///   to this vertex; contains the indices required to identify the corresponding
    ///   vertices in the character's vertex list.
    /// </param>
    /// <param name="weight">
    ///   Weight of the up to 4 vertices inbetween which the new vertex is being
    ///   created. The weight of unused vertices will be set to 0.
    /// </param>
    /// <param name="newVertexData">
    ///   Out parameter by which the vertex user data chunk for the new vertex
    ///   can be returned to the tessellator.
    /// </param>
    /// <param name="tessellationSetAddress">
    ///   TessellationSet in which to create the new vertex.
    /// </param>
    GLvoid CALLBACK tessCombine(
      GLdouble coords[3], void *vertexData[4], GLfloat weight[4], void **newVertexData,
      void *tessellationSetAddress
    ) {
      TessellationSet &tessellationSet = *static_cast<TessellationSet *>(tessellationSetAddress);

      tessellationSet.Indices.push_back(new int(tessellationSet.Vertices.size()));
      tessellationSet.Vertices.push_back(
        std::pair<float, float>(
          static_cast<float>(coords[0]),
          static_cast<float>(coords[1])
        )
      );
    }

  } // anonymous namespace

  // ------------------------------------------------------------------------------------------- //

  void FreeTypeFontTessellator::Tessellate(VectorFontCharacterContent ^characterContent) {
    TessellationSet tessellationSet;

    for each(Vector2 vertex in characterContent->Vertices) {
      tessellationSet.Indices.push_back(new int(tessellationSet.Vertices.size()));
      tessellationSet.Vertices.push_back(std::pair<float, float>(vertex.X, vertex.Y));
    }

    size_t originalVertexCount = tessellationSet.Vertices.size();

    // Set up a new OpenGL GLU tessellator to generate triangles for this character.
    GLUtesselator *tessellator = ::gluNewTess();
    try {
      ::gluTessCallback(tessellator, GLU_TESS_BEGIN_DATA, (GLvoid (CALLBACK *)())tessBegin);
      ::gluTessCallback(tessellator, GLU_TESS_END_DATA, (GLvoid (CALLBACK *)())tessEnd);
      ::gluTessCallback(tessellator, GLU_TESS_VERTEX_DATA, (GLvoid (CALLBACK *)())tessVertex);
      ::gluTessCallback(tessellator, GLU_TESS_COMBINE_DATA, (GLvoid (CALLBACK *)())tessCombine);

      // The character is announced to the tessellator as one polygon (though, technically,
      // it could be several disjoint polygon shapes, which however is ok with the
      // OpenGL GLU tessellator).
      ::gluTessBeginPolygon(tessellator, &tessellationSet);

      // Iterate over all of the character's outlines and send these to the tessellator
      for each(VectorFontCharacterContent::Outline outline in characterContent->Outlines) {
        ::gluTessBeginContour(tessellator);

        for(
          int index = outline.StartVertexIndex;
          index < (outline.StartVertexIndex + outline.VertexCount);
          ++index
        ) {
          GLdouble coords[3] = {
            static_cast<double>(tessellationSet.Vertices[index].first),
            static_cast<double>(tessellationSet.Vertices[index].second),
            0.0
          };
          
          ::gluTessVertex(tessellator, coords, tessellationSet.Indices[index]);
        }

        ::gluTessEndContour(tessellator);
      }

      ::gluTessEndPolygon(tessellator);
    }
    finally {
      ::gluDeleteTess(tessellator);
    }

    // Add any supporting vertices the tessellator has created for us
    for(size_t index = originalVertexCount; index < tessellationSet.Vertices.size(); ++index) {
      characterContent->Vertices->Add(
        Vector2(tessellationSet.Vertices[index].first, tessellationSet.Vertices[index].second)
      );
    }

    // Transfer the triangle indices generated by the tessellator into our
    // .NET structures so they can be understood by the remaining code.
    for(
      TriangleVector::const_iterator triangle = tessellationSet.Triangles.begin();
      triangle != tessellationSet.Triangles.end();
      ++triangle
    ) {
      characterContent->Faces->Add(
        VectorFontCharacterContent::Face(
          triangle->FirstVertexIndex, triangle->SecondVertexIndex, triangle->ThirdVertexIndex
        )
      );
    }
  }

  // ------------------------------------------------------------------------------------------- //

}}} // namespace Nuclex::Fonts::Content
