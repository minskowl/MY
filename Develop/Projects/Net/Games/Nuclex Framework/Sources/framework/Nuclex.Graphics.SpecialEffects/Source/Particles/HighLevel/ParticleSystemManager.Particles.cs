#region CPL License
/*
Nuclex Framework
Copyright (C) 2002-2009 Nuclex Development Labs

This library is free software; you can redistribute it and/or
modify it under the terms of the IBM Common Public License as
published by the IBM Corporation; either version 1.0 of the
License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
IBM Common Public License for more details.

You should have received a copy of the IBM Common Public
License along with this library
*/
#endregion

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Threading;

using Microsoft.Xna.Framework.Graphics;

using Nuclex.Graphics.Batching;
using Nuclex.Support;

namespace Nuclex.Graphics.SpecialEffects.Particles.HighLevel {

  partial class ParticleSystemManager {

    #region interface IParticleSystemHolder

    /// <summary>Interface for objects managing a single particle system</summary>
    private interface IParticleSystemHolder {

      /// <summary>Renders the particle system into its primitive batch</summary>
      void Render();

      /// <summary>Disposes the contained particle system</summary>
      void Dispose();

      /// <summary>Releases or destroys the referenced primitive batch</summary>
      void ReleasePrimitiveBatch();

      /// <summary>Updates the particles in the particle system</summary>
      /// <param name="updates">Number of updates that will be performed</param>
      void Update(int updates);

      /// <summary>Begins an asynchronous update on the particle system</summary>
      /// <param name="updates">Number of updates that will be performed</param>
      /// <param name="threads">Number of threads that will be used</param>
      /// <param name="callback">
      ///   Callback that will be invoked after the update has finished
      /// </param>
      /// <param name="state">User-defined state</param>
      /// <returns>
      ///   An asynchronous result handle that can be used to wait for the operation
      /// </returns>
      IAsyncResult BeginUpdate(
        int updates, int threads, AsyncCallback callback, object state
      );

      /// <summary>Ends the asynchronous update</summary>
      /// <param name="asyncResult">
      ///   Asynchronous result handle obtained from the BeginUpdate() method
      /// </param>
      void EndUpdate(IAsyncResult asyncResult);

      /// <summary>Prunes dead particles from the system</summary>
      void Prune();

      /// <summary>Begins asynchronously pruning dead particles from the system</summary>
      /// <param name="callback">
      ///   Callback that will be invoked after pruning has finished
      /// </param>
      /// <param name="state">User-defined state</param>
      /// <returns>
      ///   An asynchronous result handle that can be used to wait for the operation
      /// </returns>
      IAsyncResult BeginPrune(AsyncCallback callback, object state);

      /// <summary>Ends asynchronous pruning</summary>
      /// <param name="asyncResult">
      ///   Asynchronous result handle obtained from the BeginPrune() method
      /// </param>
      void EndPrune(IAsyncResult asyncResult);

    }

    #endregion // interface IParticleSystemHolder

    #region class ParticleSystemHolder<>

    /// <summary>Manages a particle system and its associated resources</summary>
    /// <typeparam name="ParticleType">
    ///   Type of particles being simulated in the particle system
    /// </typeparam>
    /// <typeparam name="VertexType">
    ///   Type of vertices the particle system generates
    /// </typeparam>
    private class ParticleSystemHolder<ParticleType, VertexType> : IParticleSystemHolder
      where ParticleType : struct
      where VertexType : struct
#if XNA_4
, IVertexType
#endif
 {

      /// <summary>Initializes a new particle system holder</summary>
      /// <param name="particleSystem">Particle system the holder will manage</param>
      /// <param name="renderer">
      ///   Renderer through which the particles are sent to the primitive batch
      /// </param>
      /// <param name="pruneDelegate">
      ///   Method which will be used to detect dead particles
      /// </param>
      /// <param name="primitiveBatchHolder">
      ///   Primitive batch holder that manages the primitive batch used to
      ///   render the vertices generated by this particle system
      /// </param>
      public ParticleSystemHolder(
        ParticleSystem<ParticleType> particleSystem,
        ParticleSystem<ParticleType>.PrunePredicate pruneDelegate,
        IParticleRenderer<ParticleType, VertexType> renderer,
        PrimitiveBatchHolder<VertexType> primitiveBatchHolder
      ) {
        if(renderer == null) {
          throw new ArgumentException("You must specify a renderer", "renderer");
        }

        this.particleSystem = particleSystem;
        this.pruneDelegate = pruneDelegate;
        this.renderer = renderer;
        this.primitiveBatchHolder = primitiveBatchHolder;
      }

      /// <summary>Renders the particle system into its primitive batch</summary>
      public void Render() {
        this.renderer.Render(
          this.particleSystem.Particles, this.primitiveBatchHolder.PrimitiveBatch
        );
      }

      /// <summary>Disposes the contained particle system</summary>
      public void Dispose() {
        this.particleSystem.Dispose();
      }

      /// <summary>Releases or destroys the referenced primitive batch</summary>
      public void ReleasePrimitiveBatch() {
        this.primitiveBatchHolder.Release();
      }

      /// <summary>Updates the particles in the particle system</summary>
      /// <param name="updates">Number of updates that will be performed</param>
      public void Update(int updates) {
        this.particleSystem.Update(updates);
      }

      /// <summary>Begins an asynchronous update on the particle system</summary>
      /// <param name="updates">Number of updates that will be performed</param>
      /// <param name="threads">Number of threads that will be used</param>
      /// <param name="callback">
      ///   Callback that will be invoked after the update has finished
      /// </param>
      /// <param name="state">User-defined state</param>
      /// <returns>
      ///   An asynchronous result handle that can be used to wait for the operation
      /// </returns>
      public IAsyncResult BeginUpdate(
        int updates, int threads, AsyncCallback callback, object state
      ) {
        return this.particleSystem.BeginUpdate(updates, threads, callback, state);
      }

      /// <summary>Ends the asynchronous update</summary>
      /// <param name="asyncResult">
      ///   Asynchronous result handle obtained from the BeginUpdate() method
      /// </param>
      public void EndUpdate(IAsyncResult asyncResult) {
        this.particleSystem.EndUpdate(asyncResult);
      }

      /// <summary>Prunes dead particles from the system</summary>
      public void Prune() {
        this.particleSystem.Prune(this.pruneDelegate);
      }

      /// <summary>Begins asynchronously pruning dead particles from the system</summary>
      /// <param name="callback">
      ///   Callback that will be invoked after pruning has finished
      /// </param>
      /// <param name="state">User-defined state</param>
      /// <returns>
      ///   An asynchronous result handle that can be used to wait for the operation
      /// </returns>
      public IAsyncResult BeginPrune(AsyncCallback callback, object state) {
        return this.particleSystem.BeginPrune(this.pruneDelegate, callback, state);
      }

      /// <summary>Ends asynchronous pruning</summary>
      /// <param name="asyncResult">
      ///   Asynchronous result handle obtained from the BeginPrune() method
      /// </param>
      public void EndPrune(IAsyncResult asyncResult) {
        this.particleSystem.EndPrune(asyncResult);
      }

      /// <summary>Particle system being managed by the holder</summary>
      private ParticleSystem<ParticleType> particleSystem;
      /// <summary>Particle renderer used to generate vertices from particles</summary>
      private IParticleRenderer<ParticleType, VertexType> renderer;
      /// <summary>Manages the primitive batch used to draw particles</summary>
      private PrimitiveBatchHolder<VertexType> primitiveBatchHolder;
      /// <summary>Delegate for the method used to recognize dead particles</summary>
      private ParticleSystem<ParticleType>.PrunePredicate pruneDelegate;

    }

    #endregion // class ParticleSystemHolder<>

#if !XNA_4 // TODO: Write a triangle billboard particle renderer

    /// <summary>Adds a particle system to be processed by the manager</summary>
    /// <typeparam name="ParticleType">
    ///   Type of particles being stored in the particle system
    /// </typeparam>
    /// <param name="particleSystem">
    ///   Particle system that will be added to the manager
    /// </param>
    /// <param name="pruneDelegate">Method used to detect dead particles</param>
    /// <param name="effect">Effect that will be used to render the particles</param>
    /// <remarks>
    ///   The particles will be rendered as simple point sprites using the effect.
    ///   Because 
    /// </remarks>
    public void AddParticleSystem<ParticleType>(
      ParticleSystem<ParticleType> particleSystem,
      ParticleSystem<ParticleType>.PrunePredicate pruneDelegate,
      Effect effect
    ) where ParticleType : struct
#if XNA_4
, IVertexType
#endif
 {
      AddParticleSystem<ParticleType>(
        particleSystem, pruneDelegate, new EffectDrawContext(effect)
      );
    }

    /// <summary>Adds a particle system to be processed by the manager</summary>
    /// <typeparam name="ParticleType">
    ///   Type of particles being stored in the particle system
    /// </typeparam>
    /// <param name="particleSystem">
    ///   Particle system that will be added to the manager
    /// </param>
    /// <param name="pruneDelegate">Method used to detect dead particles</param>
    /// <param name="drawContext">Drawing context using to render the particles</param>
    /// <remarks>
    ///   The particles will be rendered as simple point sprites using the effect
    ///   provided by the drawing context.
    /// </remarks>
    public void AddParticleSystem<ParticleType>(
      ParticleSystem<ParticleType> particleSystem,
      ParticleSystem<ParticleType>.PrunePredicate pruneDelegate,
      DrawContext drawContext
    ) where ParticleType : struct
#if XNA_4
, IVertexType
#endif
 {
      PrimitiveBatchHolder<ParticleType> holder;
      holder = getOrCreatePrimitiveBatch<ParticleType>();
      try {
        this.particleSystems.Add(
          particleSystem,
          new ParticleSystemHolder<ParticleType, ParticleType>(
            particleSystem,
            pruneDelegate,
            new PointParticleRenderer<ParticleType>(drawContext),
            holder
          )
        );
        this.holderArraysDirty = true;
      }
      catch(Exception) {
        holder.Release();
        throw;
      }
    }

#endif

    /// <summary>Adds a particle system to be processed by the manager</summary>
    /// <typeparam name="ParticleType">
    ///   Type of particles being stored in the particle system
    /// </typeparam>
    /// <typeparam name="VertexType">
    ///   Type of vertices that will be generated from the particles
    /// </typeparam>
    /// <param name="particleSystem">
    ///   Particle system that will be added to the manager
    /// </param>
    /// <param name="pruneDelegate">Method used to detect dead particles</param>
    /// <param name="renderer">
    ///   Particle renderer that will turn the particles into vertices and send
    ///   them to a primitive batch for rendering
    /// </param>
    public void AddParticleSystem<ParticleType, VertexType>(
      ParticleSystem<ParticleType> particleSystem,
      ParticleSystem<ParticleType>.PrunePredicate pruneDelegate,
      IParticleRenderer<ParticleType, VertexType> renderer
    )
      where ParticleType : struct
      where VertexType : struct 
#if XNA_4
, IVertexType
#endif
 {

      PrimitiveBatchHolder<VertexType> holder;
      holder = getOrCreatePrimitiveBatch<VertexType>();
      try {
        this.particleSystems.Add(
          particleSystem,
          new ParticleSystemHolder<ParticleType, VertexType>(
            particleSystem,
            pruneDelegate,
            renderer,
            holder
          )
        );
        this.holderArraysDirty = true;
      }
      catch(Exception) {
        holder.Release();
        throw;
      }

    }

    /// <summary>Removes a particle system from the manager</summary>
    /// <typeparam name="ParticleType">
    ///   Type of particles being stored in the particle system
    /// </typeparam>
    /// <param name="particleSystem">
    ///   Particle system that will be removed from the manager
    /// </param>
    public void RemoveParticleSystem<ParticleType>(
      ParticleSystem<ParticleType> particleSystem
    ) where ParticleType : struct
#if XNA_4
, IVertexType
#endif
 {
      IParticleSystemHolder holder;
      if(!this.particleSystems.TryGetValue(particleSystem, out holder)) {
        throw new ArgumentException(
          "Particle system has not been added to this manager", "particleSystem"
        );
      }

      // Get rid of the particle system and unreference the primitive batch
      // it was using for rendering
      holder.ReleasePrimitiveBatch();
      this.particleSystems.Remove(particleSystem);
      this.holderArraysDirty = true;
    }

    /// <summary>Particle systems that are being managed by this instance</summary>
    private Dictionary<object, IParticleSystemHolder> particleSystems;

  }

} // namespace Nuclex.Graphics.SpecialEffects.Particles.HighLevel
