using System;
using System.Collections.Generic;
using System.Text;

namespace Nuclex.Graphics.SpecialEffects.Trails {

/*
  /// <summary>Manages vertex buffers for trails</summary>
  public class TrailManager {
  }

  /// <summary>Movable for for </summary>
  public class TrailEmitter {

    public TrailEmitter(TrailManager manager) : this(manager, 1.0f) { }

    public TrailEmitter(TrailManager manager, float radius) {
      this.manager = manager;
      this.radius = radius;
    }

    /// <summary>Radius of the trail generated by this emitter</summary>
    public float Radius {
      get { return this.radius; }
      set { this.radius = value; }
    }

    /// <summary>Life time of the trail in seconds</summary>
    public float Lifetime {
      get { return this.lifetime; }
      set { this.lifetime = value; }
    }

    /// <summary>Trail manager hosting our generated vertices</summary>
    private TrailManager manager;
    /// <summary>The radius of this trail emitter</summary>
    private float radius;
    /// <summary>Lifetime of the generated trail</summary>
    private float lifetime;

  }

  // - Emitter only needs a radius that is then applied to the width
  //   of the trail being generated.
  //
  // - Allow for efficient trail path updates without rendering. The
  //   trail must not be dependent on frame rate, so it needs to be
  //   updateable fast without touching the graphics hardware.
  //
  // - If possible, externalize TrailRenderer so animated textures,
  //   multi-layer effects and even trail particle generation become
  //   possible.

  // DecayController {
  //   FlyweightAccessor {
  //     Age 
*/

} // namespace Nuclex.Graphics.SpecialEffects.Trails
                        