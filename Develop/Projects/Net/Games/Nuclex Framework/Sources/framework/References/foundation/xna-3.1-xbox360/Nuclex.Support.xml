<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Nuclex.Support</name>
    </assembly>
    <members>
        <member name="T:Nuclex.Support.Collections.Deque`1">
            <summary>A double-ended queue that allocates memory in blocks</summary>
            <typeparam name="ItemType">Type of the items being stored in the queue</typeparam>
            <remarks>
              <para>
                The double-ended queue allows items to be appended to either side of the queue
                without a hefty toll on performance. Like its namesake in C++, it is implemented
                using multiple arrays.
              </para>
              <para>
                Therefore, it's not only good at coping with lists that are modified at their
                beginning, but also at handling huge data sets since enlarging the deque doesn't
                require items to be copied around and still can be accessed by index.
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.#ctor">
            <summary>Initializes a new deque</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.#ctor(System.Int32)">
            <summary>Initializes a new deque using the specified block size</summary>
            <param name="blockSize">Size of the individual memory blocks used</param>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.Contains(`0)">
            <summary>Determines whether the deque contains the specified item</summary>
            <param name="item">Item the deque will be scanned for</param>
            <returns>True if the deque contains the item, false otherwise</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.CopyTo(`0[],System.Int32)">
            <summary>Copies the contents of the deque into an array</summary>
            <param name="array">Array the contents of the deque will be copied into</param>
            <param name="arrayIndex">Array index the deque contents will begin at</param>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.GetEnumerator">
            <summary>Obtains a new enumerator for the contents of the deque</summary>
            <returns>The new enumerator</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.findIndex(System.Int32,System.Int32@,System.Int32@)">
            <summary>Calculates the block index and local sub index of an entry</summary>
            <param name="index">Index of the entry that will be located</param>
            <param name="blockIndex">Index of the block the entry is contained in</param>
            <param name="subIndex">Local sub index of the entry within the block</param>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.isCompatibleObject(System.Object)">
            <summary>
              Determines whether the provided object can be placed in the deque
            </summary>
            <param name="value">Value that will be checked for compatibility</param>
            <returns>True if the value can be placed in the deque</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.verifyCompatibleObject(System.Object)">
            <summary>Verifies that the provided object matches the deque's type</summary>
            <param name="value">Value that will be checked for compatibility</param>
        </member>
        <member name="F:Nuclex.Support.Collections.Deque`1.count">
            <summary>Number if items currently stored in the deque</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.Deque`1.blockSize">
            <summary>Size of a single deque block</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.Deque`1.blocks">
            <summary>Memory blocks being used to store the deque's data</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.Deque`1.firstBlockStartIndex">
            <summary>Starting index of data in the first block</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.Deque`1.lastBlockEndIndex">
            <summary>End index of data in the last block</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.AddFirst(`0)">
            <summary>Inserts an item at the beginning of the double-ended queue</summary>
            <param name="item">Item that will be inserted into the queue</param>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.AddLast(`0)">
            <summary>Appends an item to the end of the double-ended queue</summary>
            <param name="item">Item that will be appended to the queue</param>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.Insert(System.Int32,`0)">
            <summary>Inserts the item at the specified index</summary>
            <param name="index">Index the item will be inserted at</param>
            <param name="item">Item that will be inserted</param>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.shiftLeftAndInsert(System.Int32,`0)">
            <summary>
              Shifts all items before the insertion point to the left and inserts
              the item at the specified index
            </summary>
            <param name="index">Index the item will be inserted at</param>
            <param name="item">Item that will be inserted</param>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.shiftRightAndInsert(System.Int32,`0)">
            <summary>
              Shifts all items after the insertion point to the right and inserts
              the item at the specified index
            </summary>
            <param name="index">Index the item will be inserted at</param>
            <param name="item">Item that will be inserted</param>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>Obtains a new enumerator for the contents of the deque</summary>
            <returns>The new enumerator</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.System#Collections#IList#Add(System.Object)">
            <summary>Adds an item to the deque</summary>
            <param name="value">Item that will be added to the deque</param>
            <returns>The index at which the new item was added</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.System#Collections#IList#Contains(System.Object)">
            <summary>Checks whether the deque contains the specified item</summary>
            <param name="value">Item the deque will be scanned for</param>
            <returns>True if the deque contained the specified item</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.System#Collections#IList#IndexOf(System.Object)">
            <summary>Determines the index of the item in the deque</summary>
            <param name="value">Item whose index will be determined</param>
            <returns>The index of the specified item in the deque</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.System#Collections#IList#Insert(System.Int32,System.Object)">
            <summary>Inserts an item into the deque at the specified location</summary>
            <param name="index">Index at which the item will be inserted</param>
            <param name="value">Item that will be inserted</param>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.System#Collections#IList#Remove(System.Object)">
            <summary>Removes the specified item from the deque</summary>
            <param name="value">Item that will be removed from the deque</param>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.System#Collections#Generic#ICollection{ItemType}#Add(`0)">
            <summary>Adds an item into the deque</summary>
            <param name="item">Item that will be added to the deque</param>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>Copies the contents of the deque into an array</summary>
            <param name="array">Array the contents of the deque will be copied into</param>
            <param name="index">Index at which writing into the array will begin</param>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.Clear">
            <summary>Removes all items from the deque</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.Remove(`0)">
            <summary>Removes the specified item from the deque</summary>
            <param name="item">Item that will be removed from the deque</param>
            <returns>True if the item was found and removed</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.RemoveFirst">
            <summary>Removes the first item in the double-ended queue</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.RemoveLast">
            <summary>Removes the last item in the double-ended queue</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.RemoveAt(System.Int32)">
            <summary>Removes the item at the specified index</summary>
            <param name="index">Index of the item that will be removed</param>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.removeFromLeft(System.Int32)">
            <summary>
              Removes an item from the left side of the queue by shifting all items that
              come before it to the right by one
            </summary>
            <param name="index">Index of the item that will be removed</param>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.removeFromRight(System.Int32)">
            <summary>
              Removes an item from the right side of the queue by shifting all items that
              come after it to the left by one
            </summary>
            <param name="index">Index of the item that will be removed</param>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.IndexOf(`0)">
            <summary>
              Determines the index of the first occurence of the specified item in the deque
            </summary>
            <param name="item">Item that will be located in the deque</param>
            <returns>The index of the item or -1 if it wasn't found</returns>
        </member>
        <member name="P:Nuclex.Support.Collections.Deque`1.Count">
            <summary>Number of items contained in the double ended queue</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.Deque`1.Item(System.Int32)">
            <summary>Accesses an item by its index</summary>
            <param name="index">Index of the item that will be accessed</param>
            <returns>The item at the specified index</returns>
        </member>
        <member name="P:Nuclex.Support.Collections.Deque`1.First">
            <summary>The first item in the double-ended queue</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.Deque`1.Last">
            <summary>The last item in the double-ended queue</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.Deque`1.System#Collections#IList#IsFixedSize">
            <summary>Whether the deque has a fixed size</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.Deque`1.System#Collections#IList#IsReadOnly">
            <summary>Whether the deque is read-only</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.Deque`1.System#Collections#IList#Item(System.Int32)">
            <summary>Accesses an item in the deque by its index</summary>
            <param name="index">Index of the item that will be accessed</param>
            <returns>The item at the specified index</returns>
        </member>
        <member name="P:Nuclex.Support.Collections.Deque`1.System#Collections#Generic#ICollection{ItemType}#IsReadOnly">
            <summary>Whether the collection is read-only</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.Deque`1.System#Collections#ICollection#IsSynchronized">
            <summary>Whether the deque is thread-synchronized</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.Deque`1.System#Collections#ICollection#SyncRoot">
            <summary>Synchronization root of the instance</summary>
        </member>
        <member name="T:Nuclex.Support.Collections.Deque`1.Enumerator">
            <summary>Enumerates over the items in a deque</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.Enumerator.#ctor(Nuclex.Support.Collections.Deque{`0})">
            <summary>Initializes a new deque enumerator</summary>
            <param name="deque">Deque whose items will be enumerated</param>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.Enumerator.Dispose">
            <summary>Immediately releases all resources owned by the instance</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.Enumerator.MoveNext">
            <summary>Advances the enumerator to the next item</summary>
            <returns>True if there was a next item</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.Deque`1.Enumerator.Reset">
            <summary>Resets the enumerator to its initial position</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.Deque`1.Enumerator.deque">
            <summary>Deque the enumerator belongs to</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.Deque`1.Enumerator.blockSize">
            <summary>Size of the blocks in the deque</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.Deque`1.Enumerator.lastBlock">
            <summary>Index of the last block in the deque</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.Deque`1.Enumerator.lastBlockEndIndex">
            <summary>End index of the items in the deque's last block</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.Deque`1.Enumerator.currentBlockIndex">
            <summary>Index of the block the enumerator currently is in</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.Deque`1.Enumerator.currentBlock">
            <summary>Reference to the block being enumerated</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.Deque`1.Enumerator.subIndex">
            <summary>Index in the current block</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.Deque`1.Enumerator.Current">
            <summary>The item at the enumerator's current position</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.Deque`1.Enumerator.System#Collections#IEnumerator#Current">
            <summary>The item at the enumerator's current position</summary>
        </member>
        <member name="T:Nuclex.Support.Collections.IObservableCollection`1">
            <summary>Interface for collections that can be observed</summary>
            <typeparam name="ItemType">Type of items managed in the collection</typeparam>
        </member>
        <member name="E:Nuclex.Support.Collections.IObservableCollection`1.ItemAdded">
            <summary>Raised when an item has been added to the collection</summary>
        </member>
        <member name="E:Nuclex.Support.Collections.IObservableCollection`1.ItemRemoved">
            <summary>Raised when an item is removed from the collection</summary>
        </member>
        <member name="E:Nuclex.Support.Collections.IObservableCollection`1.Clearing">
            <summary>Raised when the collection is about to be cleared</summary>
            <remarks>
              This could be covered by calling ItemRemoved for each item currently
              contained in the collection, but it is often simpler and more efficient
              to process the clearing of the entire collection as a special operation.
            </remarks>
        </member>
        <member name="E:Nuclex.Support.Collections.IObservableCollection`1.Cleared">
            <summary>Raised when the collection has been cleared of its items</summary>
        </member>
        <member name="T:Nuclex.Support.Collections.IRecyclable">
            <summary>Allows an object to be returned to its initial state</summary>
            <remarks>
              <para>
                This interface is typically implemented by objects which can be recycled
                in order to avoid the construction overhead of a heavyweight class and to
                eliminate garbage by reusing instances.
              </para>
              <para>
                Recyclable objects should have a parameterless constructor and calling
                their Recycle() method should bring them back into the state they were
                in right after they had been constructed.
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Collections.IRecyclable.Recycle">
            <summary>Returns the object to its initial state</summary>
        </member>
        <member name="T:Nuclex.Support.Collections.ItemEventArgs`1">
            <summary>
              Arguments class for collections wanting to hand over an item in an event
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ItemEventArgs`1.#ctor(`0)">
            <summary>Initializes a new event arguments supplier</summary>
            <param name="item">Item to be supplied to the event handler</param>
        </member>
        <member name="F:Nuclex.Support.Collections.ItemEventArgs`1.item">
            <summary>Item to be passed to the event handler</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ItemEventArgs`1.Item">
            <summary>Obtains the collection item the event arguments are carrying</summary>
        </member>
        <member name="T:Nuclex.Support.Collections.ObservableCollection`1">
            <summary>Collection which fires events when items are added or removed</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableCollection`1.#ctor">
            <summary>
              Initializes a new instance of the ObservableCollection class that is empty.
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableCollection`1.#ctor(System.Collections.Generic.IList{`0})">
            <summary>
              Initializes a new instance of the ObservableCollection class as a wrapper
              for the specified list.
            </summary>
            <param name="list">The list that is wrapped by the new collection.</param>
            <exception cref="T:System.ArgumentNullException">
               List is null.
            </exception>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableCollection`1.ClearItems">
            <summary>Removes all elements from the Collection</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableCollection`1.InsertItem(System.Int32,`0)">
            <summary>
              Inserts an element into the ObservableCollection at the specified index
            </summary>
            <param name="index">
              The object to insert. The value can be null for reference types.
            </param>
            <param name="item">The zero-based index at which item should be inserted</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableCollection`1.RemoveItem(System.Int32)">
            <summary>
              Removes the element at the specified index of the ObservableCollection
            </summary>
            <param name="index">The zero-based index of the element to remove</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableCollection`1.SetItem(System.Int32,`0)">
            <summary>Replaces the element at the specified index</summary>
            <param name="index">
              The new value for the element at the specified index. The value can be null
              for reference types
            </param>
            <param name="item">The zero-based index of the element to replace</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableCollection`1.OnAdded(`0)">
            <summary>Fires the 'ItemAdded' event</summary>
            <param name="item">Item that has been added to the collection</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableCollection`1.OnRemoved(`0)">
            <summary>Fires the 'ItemRemoved' event</summary>
            <param name="item">Item that has been removed from the collection</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableCollection`1.OnClearing">
            <summary>Fires the 'Clearing' event</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableCollection`1.OnCleared">
            <summary>Fires the 'Cleared' event</summary>
        </member>
        <member name="E:Nuclex.Support.Collections.ObservableCollection`1.ItemAdded">
            <summary>Raised when an item has been added to the collection</summary>
        </member>
        <member name="E:Nuclex.Support.Collections.ObservableCollection`1.ItemRemoved">
            <summary>Raised when an item is removed from the collection</summary>
        </member>
        <member name="E:Nuclex.Support.Collections.ObservableCollection`1.Clearing">
            <summary>Raised when the collection is about to be cleared</summary>
            <remarks>
              This could be covered by calling ItemRemoved for each item currently
              contained in the collection, but it is often simpler and more efficient
              to process the clearing of the entire collection as a special operation.
            </remarks>
        </member>
        <member name="E:Nuclex.Support.Collections.ObservableCollection`1.Cleared">
            <summary>Raised when the collection has been cleared</summary>
        </member>
        <member name="T:Nuclex.Support.Collections.ObservableDictionary`2">
            <summary>A dictionary that sneds out change notifications</summary>
            <typeparam name="KeyType">Type of the keys used in the dictionary</typeparam>
            <typeparam name="ValueType">Type of the values used in the dictionary</typeparam>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionary`2.#ctor">
            <summary>Initializes a new observable dictionary</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionary`2.#ctor(System.Collections.Generic.IDictionary{`0,`1})">
            <summary>Initializes a new observable Dictionary wrapper</summary>
            <param name="dictionary">Dictionary that will be wrapped</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionary`2.Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
              Determines whether the specified KeyValuePair is contained in the Dictionary
            </summary>
            <param name="item">KeyValuePair that will be checked for</param>
            <returns>True if the provided KeyValuePair was contained in the Dictionary</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionary`2.ContainsKey(`0)">
            <summary>Determines whether the Dictionary contains the specified key</summary>
            <param name="key">Key that will be checked for</param>
            <returns>
              True if an entry with the specified key was contained in the Dictionary
            </returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionary`2.CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
            <summary>Copies the contents of the Dictionary into an array</summary>
            <param name="array">Array the Dictionary will be copied into</param>
            <param name="arrayIndex">
              Starting index at which to begin filling the destination array
            </param>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionary`2.GetEnumerator">
            <summary>Creates a new enumerator for the Dictionary</summary>
            <returns>The new Dictionary enumerator</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionary`2.TryGetValue(`0,`1@)">
            <summary>
              Attempts to retrieve the item with the specified key from the Dictionary
            </summary>
            <param name="key">Key of the item to attempt to retrieve</param>
            <param name="value">
              Output parameter that will receive the key upon successful completion
            </param>
            <returns>
              True if the item was found and has been placed in the output parameter
            </returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionary`2.Add(`0,`1)">
            <summary>Inserts an item into the Dictionary</summary>
            <param name="key">Key under which to add the new item</param>
            <param name="value">Item that will be added to the Dictionary</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionary`2.Remove(`0)">
            <summary>Removes the item with the specified key from the Dictionary</summary>
            <param name="key">Key of the elementes that will be removed</param>
            <returns>True if an item with the specified key was found and removed</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionary`2.Clear">
            <summary>Removes all items from the Dictionary</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionary`2.OnAdded(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>Fires the 'ItemAdded' event</summary>
            <param name="item">Item that has been added to the collection</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionary`2.OnRemoved(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>Fires the 'ItemRemoved' event</summary>
            <param name="item">Item that has been removed from the collection</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionary`2.OnClearing">
            <summary>Fires the 'Clearing' event</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionary`2.OnCleared">
            <summary>Fires the 'Cleared' event</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionary`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>Returns a new object enumerator for the Dictionary</summary>
            <returns>The new object enumerator</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionary`2.System#Collections#IDictionary#Add(System.Object,System.Object)">
            <summary>Adds an item into the Dictionary</summary>
            <param name="key">Key under which the item will be added</param>
            <param name="value">Item that will be added</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionary`2.System#Collections#IDictionary#Contains(System.Object)">
            <summary>Determines whether the specified key exists in the Dictionary</summary>
            <param name="key">Key that will be checked for</param>
            <returns>True if an item with the specified key exists in the Dictionary</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionary`2.System#Collections#IDictionary#GetEnumerator">
            <summary>Returns a new entry enumerator for the dictionary</summary>
            <returns>The new entry enumerator</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionary`2.System#Collections#IDictionary#Remove(System.Object)">
            <summary>Removes an item from the Dictionary</summary>
            <param name="key">Key of the item that will be removed</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{KeyType@ValueType}}#Add(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>Inserts an already prepared element into the Dictionary</summary>
            <param name="item">Prepared element that will be added to the Dictionary</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{KeyType@ValueType}}#Clear">
            <summary>Removes all items from the Dictionary</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{KeyType@ValueType}}#Remove(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>Removes all items from the Dictionary</summary>
            <param name="itemToRemove">Item that will be removed from the Dictionary</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ObservableDictionary`2.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>Copies the contents of the Dictionary into an array</summary>
            <param name="array">Array the Dictionary contents will be copied into</param>
            <param name="index">
              Starting index at which to begin filling the destination array
            </param>
        </member>
        <member name="F:Nuclex.Support.Collections.ObservableDictionary`2.typedDictionary">
            <summary>The wrapped Dictionary under its type-safe interface</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.ObservableDictionary`2.objectDictionary">
            <summary>The wrapped Dictionary under its object interface</summary>
        </member>
        <member name="E:Nuclex.Support.Collections.ObservableDictionary`2.ItemAdded">
            <summary>Raised when an item has been added to the dictionary</summary>
        </member>
        <member name="E:Nuclex.Support.Collections.ObservableDictionary`2.ItemRemoved">
            <summary>Raised when an item is removed from the dictionary</summary>
        </member>
        <member name="E:Nuclex.Support.Collections.ObservableDictionary`2.Clearing">
            <summary>Raised when the dictionary is about to be cleared</summary>
        </member>
        <member name="E:Nuclex.Support.Collections.ObservableDictionary`2.Cleared">
            <summary>Raised when the dictionary has been cleared</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ObservableDictionary`2.IsReadOnly">
            <summary>Whether the directory is write-protected</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ObservableDictionary`2.Count">
            <summary>Number of elements contained in the Dictionary</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ObservableDictionary`2.Keys">
            <summary>Collection of all keys contained in the Dictionary</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ObservableDictionary`2.Values">
            <summary>Collection of all values contained in the Dictionary</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ObservableDictionary`2.Item(`0)">
            <summary>Accesses an item in the Dictionary by its key</summary>
            <param name="key">Key of the item that will be accessed</param>
        </member>
        <member name="P:Nuclex.Support.Collections.ObservableDictionary`2.System#Collections#IDictionary#IsFixedSize">
            <summary>Whether the size of the Dictionary is fixed</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ObservableDictionary`2.System#Collections#IDictionary#Keys">
            <summary>Returns a collection of all keys in the Dictionary</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ObservableDictionary`2.System#Collections#IDictionary#Values">
            <summary>Returns a collection of all values stored in the Dictionary</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ObservableDictionary`2.System#Collections#IDictionary#Item(System.Object)">
            <summary>Accesses an item in the Dictionary by its key</summary>
            <param name="key">Key of the item that will be accessed</param>
            <returns>The item with the specified key</returns>
        </member>
        <member name="P:Nuclex.Support.Collections.ObservableDictionary`2.System#Collections#ICollection#IsSynchronized">
            <summary>Whether the Dictionary is synchronized for multi-threaded usage</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ObservableDictionary`2.System#Collections#ICollection#SyncRoot">
            <summary>Synchronization root on which the Dictionary locks</summary>
        </member>
        <member name="T:Nuclex.Support.Collections.PairPriorityQueue`2">
            <summary>Queue that dequeues items in order of their priority</summary>
            <remarks>
              This variant of the priority queue uses an external priority value. If the
              priority data type implements the IComparable interface, the user does not
              even
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Collections.PairPriorityQueue`2.#ctor">
            <summary>Initializes a new non-intrusive priority queue</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.PairPriorityQueue`2.#ctor(System.Collections.Generic.IComparer{`0})">
            <summary>Initializes a new non-intrusive priority queue</summary>
            <param name="priorityComparer">Comparer used to compare the item priorities</param>
        </member>
        <member name="M:Nuclex.Support.Collections.PairPriorityQueue`2.Peek">
            <summary>Returns the topmost item in the queue without dequeueing it</summary>
            <returns>The topmost item in the queue</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.PairPriorityQueue`2.Dequeue">
            <summary>Takes the item with the highest priority off from the queue</summary>
            <returns>The item with the highest priority in the list</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.PairPriorityQueue`2.Enqueue(`0,`1)">
            <summary>Puts an item into the priority queue</summary>
            <param name="priority">Priority of the item to be queued</param>
            <param name="item">Item to be queued</param>
        </member>
        <member name="M:Nuclex.Support.Collections.PairPriorityQueue`2.Clear">
            <summary>Removes all items from the priority queue</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.PairPriorityQueue`2.CopyTo(System.Array,System.Int32)">
            <summary>Copies the contents of the priority queue into an array</summary>
            <param name="array">Array to copy the priority queue into</param>
            <param name="index">Starting index for the destination array</param>
        </member>
        <member name="M:Nuclex.Support.Collections.PairPriorityQueue`2.GetEnumerator">
            <summary>Returns a typesafe enumerator for the priority queue</summary>
            <returns>A new enumerator for the priority queue</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.PairPriorityQueue`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>Returns an enumerator for the priority queue</summary>
            <returns>A new enumerator for the priority queue</returns>
        </member>
        <member name="F:Nuclex.Support.Collections.PairPriorityQueue`2.internalQueue">
            <summary>Intrusive priority queue being wrapped by this class</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.PairPriorityQueue`2.Count">
            <summary>Total number of items in the priority queue</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.PairPriorityQueue`2.SyncRoot">
            <summary>
              Obtains an object that can be used to synchronize accesses to the priority queue
              from different threads
            </summary>
        </member>
        <member name="P:Nuclex.Support.Collections.PairPriorityQueue`2.IsSynchronized">
            <summary>Whether operations performed on this priority queue are thread safe</summary>
        </member>
        <member name="T:Nuclex.Support.Collections.PairPriorityQueue`2.PairComparer">
            <summary>Compares two priority queue entries based on their priority</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.PairPriorityQueue`2.PairComparer.#ctor(System.Collections.Generic.IComparer{`0})">
            <summary>Initializes a new entry comparer</summary>
            <param name="priorityComparer">Comparer used to compare entry priorities</param>
        </member>
        <member name="M:Nuclex.Support.Collections.PairPriorityQueue`2.PairComparer.Compare(Nuclex.Support.Collections.PriorityItemPair{`0,`1},Nuclex.Support.Collections.PriorityItemPair{`0,`1})">
            <summary>Compares the left entry to the right entry</summary>
            <param name="left">Entry on the left side</param>
            <param name="right">Entry on the right side</param>
            <returns>The relationship of the two entries</returns>
        </member>
        <member name="F:Nuclex.Support.Collections.PairPriorityQueue`2.PairComparer.priorityComparer">
            <summary>Comparer used to compare the priorities of the entries</summary>
        </member>
        <member name="T:Nuclex.Support.Collections.Parentable`1">
            <summary>Base class for objects that can be parented to an owner</summary>
            <typeparam name="ParentType">Type of the parent object</typeparam>
        </member>
        <member name="M:Nuclex.Support.Collections.Parentable`1.OnParentChanged(`0)">
            <summary>Invoked whenever the instance's owner changes</summary>
            <remarks>
              When items are parented for the first time, the oldParent argument will
              be null. Also, if the element is removed from the collection, the
              current parent will be null.
            </remarks>
            <param name="oldParent">Previous owner of the instance</param>
        </member>
        <member name="M:Nuclex.Support.Collections.Parentable`1.SetParent(`0)">
            <summary>Assigns a new parent to this instance</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.Parentable`1.parent">
            <summary>Current parent of this object</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.Parentable`1.Parent">
            <summary>The parent object that owns this instance</summary>
        </member>
        <member name="T:Nuclex.Support.Collections.ParentingCollection`2">
            <summary>Collection that automatically assigns an owner to all its elements</summary>
            <remarks>
              This collection automatically assigns a parent object to elements that
              are managed in it. The elements have to derive from the Parentable&lt;&gt;
              base class.
            </remarks>
            <typeparam name="ParentType">Type of the parent object to assign to items</typeparam>
            <typeparam name="ItemType">Type of the items being managed in the collection</typeparam>
        </member>
        <member name="M:Nuclex.Support.Collections.ParentingCollection`2.Reparent(`0)">
            <summary>Reparents all elements in the collection</summary>
            <param name="parent">New parent to take ownership of the items</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ParentingCollection`2.ClearItems">
            <summary>Clears all elements from the collection</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ParentingCollection`2.InsertItem(System.Int32,`1)">
            <summary>Inserts a new element into the collection</summary>
            <param name="index">Index at which to insert the element</param>
            <param name="item">Item to be inserted</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ParentingCollection`2.RemoveItem(System.Int32)">
            <summary>Removes an element from the collection</summary>
            <param name="index">Index of the element to remove</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ParentingCollection`2.SetItem(System.Int32,`1)">
            <summary>Takes over a new element that is directly assigned</summary>
            <param name="index">Index of the element that was assigned</param>
            <param name="item">New item</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ParentingCollection`2.DisposeItems">
            <summary>Disposes all items contained in the collection</summary>
            <remarks>
              <para>
                This method is intended to support collections that need to dispose their
                items. It will unparent all of the collection's items and call Dispose()
                on any item that implements IDisposable.
              </para>
              <para>
                Do not call this method from your destructor as it will access the
                contained items in order to unparent and to Dispose() them, which leads
                to undefined behavior since the object might have already been collected
                by the GC. Call it only if your object is being manually disposed.
              </para>
            </remarks>
        </member>
        <member name="F:Nuclex.Support.Collections.ParentingCollection`2.parent">
            <summary>Parent this collection currently belongs to</summary>
        </member>
        <member name="T:Nuclex.Support.Collections.Pool`1">
            <summary>Pool that recycles objects in order to avoid garbage build-up</summary>
            <typeparam name="ItemType">Type of objects being pooled</typeparam>
            <remarks>
              <para>
                Use this class to recycle objects instead of letting them become garbage,
                creating new instances each time. The Pool class is designed to either be
                used on its own or as a building block for a static class that wraps it.
              </para>
              <para>
                Special care has to be taken to revert the entire state of a recycled
                object when it is returned to the pool. For example, events will need to
                have their subscriber lists emptied to avoid sending out events to the
                wrong subscribers and accumulating more and more subscribers each time
                they are reused.
              </para>
              <para>
                To simplify such cleanup, pooled objects can implement the IRecyclable
                interface. When an object is returned to the pool, the pool will
                automatically call its IRecyclable.Recycle() method.
              </para>
            </remarks>
        </member>
        <member name="F:Nuclex.Support.Collections.Pool`1.DefaultPoolSize">
            <summary>Default number of recyclable objects the pool will store</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.Pool`1.#ctor">
            <summary>Initializes a new pool using the default capacity</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.Pool`1.#ctor(System.Int32)">
            <summary>Initializes a new pool using a user-specified capacity</summary>
            <param name="capacity">Capacity of the pool</param>
        </member>
        <member name="M:Nuclex.Support.Collections.Pool`1.Get">
            <summary>
              Returns a new or recycled instance of the types managed by the pool
            </summary>
            <returns>A new or recycled instance</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.Pool`1.Redeem(`0)">
            <summary>
              Redeems an instance that is no longer used to be recycled by the pool
            </summary>
            <param name="item">The instance that will be redeemed</param>
        </member>
        <member name="M:Nuclex.Support.Collections.Pool`1.callRecycleIfSupported(`0)">
            <summary>
              Calls the Recycle() method on an objects if it implements
              the IRecyclable interface
            </summary>
            <param name="item">
              Object whose Recycle() method will be called if supported by the object
            </param>
        </member>
        <member name="F:Nuclex.Support.Collections.Pool`1.items">
            <summary>Objects being retained for recycling</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.Pool`1.capacity">
            <summary>Capacity of the pool</summary>
            <remarks>
              Required because the Queue class doesn't allow this value to be retrieved
            </remarks>
        </member>
        <member name="P:Nuclex.Support.Collections.Pool`1.Capacity">
            <summary>Number of objects the pool can retain</summary>
            <remarks>
              Changing this value causes the pool to be emtpied. It is recommended that
              you only read the pool's capacity, never change it.
            </remarks>
        </member>
        <member name="T:Nuclex.Support.Collections.PriorityItemPair`2">
            <summary>An pair of a priority and an item</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.PriorityItemPair`2.#ctor(`0,`1)">
            <summary>Initializes a new priority / item pair</summary>
            <param name="priority">Priority of the item in the pair</param>
            <param name="item">Item to be stored in the pair</param>
        </member>
        <member name="F:Nuclex.Support.Collections.PriorityItemPair`2.Priority">
            <summary>Priority assigned to this priority / item pair</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.PriorityItemPair`2.Item">
            <summary>Item contained in this priority / item pair</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.PriorityItemPair`2.ToString">
            <summary>Converts the priority / item pair into a string</summary>
            <returns>A string describing the priority / item pair</returns>
        </member>
        <member name="T:Nuclex.Support.Collections.PriorityQueue`1">
            <summary>Queue that dequeues items in order of their priority</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.PriorityQueue`1.#ctor">
            <summary>
              Initializes a new priority queue using IComparable for comparing items
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.PriorityQueue`1.#ctor(System.Collections.Generic.IComparer{`0})">
            <summary>Initializes a new priority queue</summary>
            <param name="comparer">Comparer to use for ordering the items</param>
        </member>
        <member name="M:Nuclex.Support.Collections.PriorityQueue`1.Peek">
            <summary>Returns the topmost item in the queue without dequeueing it</summary>
            <returns>The topmost item in the queue</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.PriorityQueue`1.Dequeue">
            <summary>Takes the item with the highest priority off from the queue</summary>
            <returns>The item with the highest priority in the list</returns>
            <exception cref="T:System.InvalidOperationException">When the queue is empty</exception>
        </member>
        <member name="M:Nuclex.Support.Collections.PriorityQueue`1.Enqueue(`0)">
            <summary>Puts an item into the priority queue</summary>
            <param name="item">Item to be queued</param>
        </member>
        <member name="M:Nuclex.Support.Collections.PriorityQueue`1.Clear">
            <summary>Removes all items from the priority queue</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.PriorityQueue`1.CopyTo(System.Array,System.Int32)">
            <summary>Copies the contents of the priority queue into an array</summary>
            <param name="array">Array to copy the priority queue into</param>
            <param name="index">Starting index for the destination array</param>
        </member>
        <member name="M:Nuclex.Support.Collections.PriorityQueue`1.GetEnumerator">
            <summary>Returns a typesafe enumerator for the priority queue</summary>
            <returns>A new enumerator for the priority queue</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.PriorityQueue`1.bubbleUp(System.Int32,`0)">
            <summary>Moves an item upwards in the heap tree</summary>
            <param name="index">Index of the item to be moved</param>
            <param name="item">Item to be moved</param>
        </member>
        <member name="M:Nuclex.Support.Collections.PriorityQueue`1.trickleDown(System.Int32,`0)">
            <summary>Move the item downwards in the heap tree</summary>
            <param name="index">Index of the item to be moved</param>
            <param name="item">Item to be moved</param>
        </member>
        <member name="M:Nuclex.Support.Collections.PriorityQueue`1.getLeftChild(System.Int32)">
            <summary>Obtains the left child item in the heap tree</summary>
            <param name="index">Index of the item whose left child to return</param>
            <returns>The left child item of the provided parent item</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.PriorityQueue`1.getParent(System.Int32)">
            <summary>Calculates the parent entry of the item on the heap</summary>
            <param name="index">Index of the item whose parent to calculate</param>
            <returns>The index of the parent to the specified item</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.PriorityQueue`1.growHeap">
            <summary>Increases the size of the priority collection's heap</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.PriorityQueue`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>Returns an enumerator for the priority queue</summary>
            <returns>A new enumerator for the priority queue</returns>
        </member>
        <member name="F:Nuclex.Support.Collections.PriorityQueue`1.comparer">
            <summary>Comparer used to order the items in the priority queue</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.PriorityQueue`1.count">
            <summary>Total number of items in the priority queue</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.PriorityQueue`1.capacity">
            <summary>Available space in the priority queue</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.PriorityQueue`1.heap">
            <summary>Tree containing the items in the priority queue</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.PriorityQueue`1.Count">
            <summary>Total number of items in the priority queue</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.PriorityQueue`1.SyncRoot">
            <summary>
              Obtains an object that can be used to synchronize accesses to the priority queue
              from different threads
            </summary>
        </member>
        <member name="P:Nuclex.Support.Collections.PriorityQueue`1.IsSynchronized">
            <summary>Whether operations performed on this priority queue are thread safe</summary>
        </member>
        <member name="T:Nuclex.Support.Collections.PriorityQueue`1.Enumerator">
            <summary>Enumerates all items contained in a priority queue</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.PriorityQueue`1.Enumerator.#ctor(Nuclex.Support.Collections.PriorityQueue{`0})">
            <summary>Initializes a new priority queue enumerator</summary>
            <param name="priorityQueue">Priority queue to be enumerated</param>
        </member>
        <member name="M:Nuclex.Support.Collections.PriorityQueue`1.Enumerator.Reset">
            <summary>Resets the enumerator to its initial state</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.PriorityQueue`1.Enumerator.MoveNext">
            <summary>Moves to the next item in the priority queue</summary>
            <returns>True if a next item was found, false if the end has been reached</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.PriorityQueue`1.Enumerator.Dispose">
            <summary>Releases all resources used by the enumerator</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.PriorityQueue`1.Enumerator.index">
            <summary>Index of the current item in the priority queue</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.PriorityQueue`1.Enumerator.priorityQueue">
            <summary>The priority queue whose items this instance enumerates</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.PriorityQueue`1.Enumerator.System#Collections#Generic#IEnumerator{ItemType}#Current">
            <summary>The current item being enumerated</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.PriorityQueue`1.Enumerator.System#Collections#IEnumerator#Current">
            <summary>The current item being enumerated</summary>
        </member>
        <member name="T:Nuclex.Support.Collections.ReadOnlyCollection`1">
            <summary>Wraps a Collection and prevents users from modifying it</summary>
            <typeparam name="ItemType">Type of items to manage in the Collection</typeparam>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyCollection`1.#ctor(System.Collections.Generic.ICollection{`0})">
            <summary>Initializes a new read-only Collection wrapper</summary>
            <param name="collection">Collection that will be wrapped</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyCollection`1.Contains(`0)">
            <summary>Determines whether the List contains the specified item</summary>
            <param name="item">Item that will be checked for</param>
            <returns>True if the specified item is contained in the List</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyCollection`1.CopyTo(`0[],System.Int32)">
            <summary>Copies the contents of the List into an array</summary>
            <param name="array">Array the List will be copied into</param>
            <param name="arrayIndex">
              Starting index at which to begin filling the destination array
            </param>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyCollection`1.GetEnumerator">
            <summary>Returns a new enumerator over the contents of the List</summary>
            <returns>The new List contents enumerator</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyCollection`1.System#Collections#Generic#ICollection{ItemType}#Add(`0)">
            <summary>Adds an item to the end of the List</summary>
            <param name="item">Item that will be added to the List</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyCollection`1.System#Collections#Generic#ICollection{ItemType}#Clear">
            <summary>Removes all items from the List</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyCollection`1.System#Collections#Generic#ICollection{ItemType}#Remove(`0)">
            <summary>Removes the specified item from the List</summary>
            <param name="item">Item that will be removed from the List</param>
            <returns>True of the specified item was found in the List and removed</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyCollection`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>Returns a new enumerator over the contents of the List</summary>
            <returns>The new List contents enumerator</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyCollection`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>Copies the contents of the List into an array</summary>
            <param name="array">Array the List will be copied into</param>
            <param name="index">
              Starting index at which to begin filling the destination array
            </param>
        </member>
        <member name="F:Nuclex.Support.Collections.ReadOnlyCollection`1.typedCollection">
            <summary>The wrapped Collection under its type-safe interface</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.ReadOnlyCollection`1.objectCollection">
            <summary>The wrapped Collection under its object interface</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ReadOnlyCollection`1.Count">
            <summary>The number of items current contained in the List</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ReadOnlyCollection`1.IsReadOnly">
            <summary>Whether the List is write-protected</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ReadOnlyCollection`1.System#Collections#ICollection#IsSynchronized">
            <summary>Whether the List is synchronized for multi-threaded usage</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ReadOnlyCollection`1.System#Collections#ICollection#SyncRoot">
            <summary>Synchronization root on which the List locks</summary>
        </member>
        <member name="T:Nuclex.Support.Collections.ReadOnlyDictionary`2">
            <summary>Wraps a dictionary and prevents users from modifying it</summary>
            <typeparam name="KeyType">Type of the keys used in the dictionary</typeparam>
            <typeparam name="ValueType">Type of the values used in the dictionary</typeparam>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionary`2.#ctor(System.Collections.Generic.IDictionary{`0,`1})">
            <summary>Initializes a new read-only dictionary wrapper</summary>
            <param name="dictionary">Dictionary that will be wrapped</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionary`2.Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
              Determines whether the specified KeyValuePair is contained in the Dictionary
            </summary>
            <param name="item">KeyValuePair that will be checked for</param>
            <returns>True if the provided KeyValuePair was contained in the Dictionary</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionary`2.ContainsKey(`0)">
            <summary>Determines whether the Dictionary contains the specified key</summary>
            <param name="key">Key that will be checked for</param>
            <returns>
              True if an entry with the specified key was contained in the Dictionary
            </returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionary`2.CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
            <summary>Copies the contents of the Dictionary into an array</summary>
            <param name="array">Array the Dictionary will be copied into</param>
            <param name="arrayIndex">
              Starting index at which to begin filling the destination array
            </param>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionary`2.GetEnumerator">
            <summary>Creates a new enumerator for the Dictionary</summary>
            <returns>The new Dictionary enumerator</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionary`2.TryGetValue(`0,`1@)">
            <summary>
              Attempts to retrieve the item with the specified key from the Dictionary
            </summary>
            <param name="key">Key of the item to attempt to retrieve</param>
            <param name="value">
              Output parameter that will receive the key upon successful completion
            </param>
            <returns>
              True if the item was found and has been placed in the output parameter
            </returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionary`2.System#Collections#Generic#IDictionary{KeyType@ValueType}#Add(`0,`1)">
            <summary>Inserts an item into the Dictionary</summary>
            <param name="key">Key under which to add the new item</param>
            <param name="value">Item that will be added to the Dictionary</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionary`2.System#Collections#Generic#IDictionary{KeyType@ValueType}#Remove(`0)">
            <summary>Removes the item with the specified key from the Dictionary</summary>
            <param name="key">Key of the elementes that will be removed</param>
            <returns>True if an item with the specified key was found and removed</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionary`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>Returns a new object enumerator for the Dictionary</summary>
            <returns>The new object enumerator</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionary`2.System#Collections#IDictionary#Clear">
            <summary>Removes all items from the Dictionary</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionary`2.System#Collections#IDictionary#Add(System.Object,System.Object)">
            <summary>Adds an item into the Dictionary</summary>
            <param name="key">Key under which the item will be added</param>
            <param name="value">Item that will be added</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionary`2.System#Collections#IDictionary#Contains(System.Object)">
            <summary>Determines whether the specified key exists in the Dictionary</summary>
            <param name="key">Key that will be checked for</param>
            <returns>True if an item with the specified key exists in the Dictionary</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionary`2.System#Collections#IDictionary#GetEnumerator">
            <summary>Returns a new entry enumerator for the dictionary</summary>
            <returns>The new entry enumerator</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionary`2.System#Collections#IDictionary#Remove(System.Object)">
            <summary>Removes an item from the Dictionary</summary>
            <param name="key">Key of the item that will be removed</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{KeyType@ValueType}}#Add(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>Inserts an already prepared element into the Dictionary</summary>
            <param name="item">Prepared element that will be added to the Dictionary</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{KeyType@ValueType}}#Clear">
            <summary>Removes all items from the Dictionary</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{KeyType@ValueType}}#Remove(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>Removes all items from the Dictionary</summary>
            <param name="itemToRemove">Item that will be removed from the Dictionary</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyDictionary`2.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>Copies the contents of the Dictionary into an array</summary>
            <param name="array">Array the Dictionary contents will be copied into</param>
            <param name="index">
              Starting index at which to begin filling the destination array
            </param>
        </member>
        <member name="F:Nuclex.Support.Collections.ReadOnlyDictionary`2.typedDictionary">
            <summary>The wrapped Dictionary under its type-safe interface</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.ReadOnlyDictionary`2.objectDictionary">
            <summary>The wrapped Dictionary under its object interface</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.ReadOnlyDictionary`2.readonlyKeyCollection">
            <summary>ReadOnly wrapper for the keys collection of the Dictionary</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.ReadOnlyDictionary`2.readonlyValueCollection">
            <summary>ReadOnly wrapper for the values collection of the Dictionary</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ReadOnlyDictionary`2.IsReadOnly">
            <summary>Whether the directory is write-protected</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ReadOnlyDictionary`2.Count">
            <summary>Number of elements contained in the Dictionary</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ReadOnlyDictionary`2.Keys">
            <summary>Collection of all keys contained in the Dictionary</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ReadOnlyDictionary`2.Values">
            <summary>Collection of all values contained in the Dictionary</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ReadOnlyDictionary`2.Item(`0)">
            <summary>Accesses an item in the Dictionary by its key</summary>
            <param name="key">Key of the item that will be accessed</param>
        </member>
        <member name="P:Nuclex.Support.Collections.ReadOnlyDictionary`2.System#Collections#Generic#IDictionary{KeyType@ValueType}#Item(`0)">
            <summary>Accesses an item in the Dictionary by its key</summary>
            <param name="key">Key of the item that will be accessed</param>
        </member>
        <member name="P:Nuclex.Support.Collections.ReadOnlyDictionary`2.System#Collections#IDictionary#IsFixedSize">
            <summary>Whether the size of the Dictionary is fixed</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ReadOnlyDictionary`2.System#Collections#IDictionary#Keys">
            <summary>Returns a collection of all keys in the Dictionary</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ReadOnlyDictionary`2.System#Collections#IDictionary#Values">
            <summary>Returns a collection of all values stored in the Dictionary</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ReadOnlyDictionary`2.System#Collections#IDictionary#Item(System.Object)">
            <summary>Accesses an item in the Dictionary by its key</summary>
            <param name="key">Key of the item that will be accessed</param>
            <returns>The item with the specified key</returns>
        </member>
        <member name="P:Nuclex.Support.Collections.ReadOnlyDictionary`2.System#Collections#ICollection#IsSynchronized">
            <summary>Whether the Dictionary is synchronized for multi-threaded usage</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ReadOnlyDictionary`2.System#Collections#ICollection#SyncRoot">
            <summary>Synchronization root on which the Dictionary locks</summary>
        </member>
        <member name="T:Nuclex.Support.Collections.ReadOnlyList`1">
            <summary>Wraps a List and prevents users from modifying it</summary>
            <typeparam name="ItemType">Type of items to manage in the List</typeparam>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyList`1.#ctor(System.Collections.Generic.IList{`0})">
            <summary>Initializes a new read-only List wrapper</summary>
            <param name="list">List that will be wrapped</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyList`1.IndexOf(`0)">
            <summary>Retrieves the index of an item within the List</summary>
            <param name="item">Item whose index will be returned</param>
            <returns>The zero-based index of the specified item in the List</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyList`1.Contains(`0)">
            <summary>Determines whether the List contains the specified item</summary>
            <param name="item">Item that will be checked for</param>
            <returns>True if the specified item is contained in the List</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyList`1.CopyTo(`0[],System.Int32)">
            <summary>Copies the contents of the List into an array</summary>
            <param name="array">Array the List will be copied into</param>
            <param name="arrayIndex">
              Starting index at which to begin filling the destination array
            </param>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyList`1.GetEnumerator">
            <summary>Returns a new enumerator over the contents of the List</summary>
            <returns>The new List contents enumerator</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyList`1.System#Collections#Generic#IList{ItemType}#Insert(System.Int32,`0)">
            <summary>Inserts an item into the List</summary>
            <param name="index">Zero-based index before which the item will be inserted</param>
            <param name="item">Item that will be inserted into the List</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyList`1.System#Collections#Generic#IList{ItemType}#RemoveAt(System.Int32)">
            <summary>Removes an item from the list</summary>
            <param name="index">Zero-based index of the item that will be removed</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyList`1.System#Collections#Generic#ICollection{ItemType}#Add(`0)">
            <summary>Adds an item to the end of the List</summary>
            <param name="item">Item that will be added to the List</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyList`1.System#Collections#Generic#ICollection{ItemType}#Clear">
            <summary>Removes all items from the List</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyList`1.System#Collections#Generic#ICollection{ItemType}#Remove(`0)">
            <summary>Removes the specified item from the List</summary>
            <param name="item">Item that will be removed from the List</param>
            <returns>True of the specified item was found in the List and removed</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyList`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>Returns a new enumerator over the contents of the List</summary>
            <returns>The new List contents enumerator</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyList`1.System#Collections#IList#Clear">
            <summary>Removes all items from the List</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyList`1.System#Collections#IList#Add(System.Object)">
            <summary>Adds an item to the end of the List</summary>
            <param name="value">Item that will be added to the List</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyList`1.System#Collections#IList#Contains(System.Object)">
            <summary>Determines whether the List contains the specified item</summary>
            <param name="value">Item that will be checked for</param>
            <returns>True if the specified item is contained in the List</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyList`1.System#Collections#IList#IndexOf(System.Object)">
            <summary>Retrieves the index of an item within the List</summary>
            <param name="value">Item whose index will be returned</param>
            <returns>The zero-based index of the specified item in the List</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyList`1.System#Collections#IList#Insert(System.Int32,System.Object)">
            <summary>Inserts an item into the List</summary>
            <param name="index">Zero-based index before which the item will be inserted</param>
            <param name="value">Item that will be inserted into the List</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyList`1.System#Collections#IList#Remove(System.Object)">
            <summary>Removes the specified item from the List</summary>
            <param name="value">Item that will be removed from the List</param>
            <returns>True of the specified item was found in the List and removed</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyList`1.System#Collections#IList#RemoveAt(System.Int32)">
            <summary>Removes an item from the list</summary>
            <param name="index">Zero-based index of the item that will be removed</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ReadOnlyList`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>Copies the contents of the List into an array</summary>
            <param name="array">Array the List will be copied into</param>
            <param name="index">
              Starting index at which to begin filling the destination array
            </param>
        </member>
        <member name="F:Nuclex.Support.Collections.ReadOnlyList`1.typedList">
            <summary>The wrapped List under its type-safe interface</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.ReadOnlyList`1.objectList">
            <summary>The wrapped List under its object interface</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ReadOnlyList`1.Item(System.Int32)">
            <summary>Accesses the List item with the specified index</summary>
            <param name="index">Zero-based index of the List item that will be accessed</param>
        </member>
        <member name="P:Nuclex.Support.Collections.ReadOnlyList`1.Count">
            <summary>The number of items current contained in the List</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ReadOnlyList`1.IsReadOnly">
            <summary>Whether the List is write-protected</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ReadOnlyList`1.System#Collections#Generic#IList{ItemType}#Item(System.Int32)">
            <summary>Accesses the List item with the specified index</summary>
            <param name="index">Zero-based index of the List item that will be accessed</param>
        </member>
        <member name="P:Nuclex.Support.Collections.ReadOnlyList`1.System#Collections#IList#IsFixedSize">
            <summary>Whether the size of the List is fixed</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ReadOnlyList`1.System#Collections#IList#Item(System.Int32)">
            <summary>Accesses the List item with the specified index</summary>
            <param name="index">Zero-based index of the List item that will be accessed</param>
        </member>
        <member name="P:Nuclex.Support.Collections.ReadOnlyList`1.System#Collections#ICollection#IsSynchronized">
            <summary>Whether the List is synchronized for multi-threaded usage</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.ReadOnlyList`1.System#Collections#ICollection#SyncRoot">
            <summary>Synchronization root on which the List locks</summary>
        </member>
        <member name="T:Nuclex.Support.Collections.ReverseComparer`1">
            <summary>
              Compares two values in reverse or reverses the output of another comparer
            </summary>
            <typeparam name="ComparedType">Type of values to be compared</typeparam>
        </member>
        <member name="M:Nuclex.Support.Collections.ReverseComparer`1.#ctor">
            <summary>Initializes a new reverse comparer</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.ReverseComparer`1.#ctor(System.Collections.Generic.IComparer{`0})">
            <summary>
              Initializes the comparer to provide the inverse results of another comparer
            </summary>
            <param name="comparerToReverse">Comparer whose results will be inversed</param>
        </member>
        <member name="M:Nuclex.Support.Collections.ReverseComparer`1.Compare(`0,`0)">
            <summary>Compares the left value to the right value</summary>
            <param name="left">Value on the left side</param>
            <param name="right">Value on the right side</param>
            <returns>The relationship of the two values</returns>
        </member>
        <member name="F:Nuclex.Support.Collections.ReverseComparer`1.comparer">
            <summary>The default comparer from the .NET framework</summary>
        </member>
        <member name="T:Nuclex.Support.AffineThreadPool">
            <summary>Alternative Thread pool providing one thread for each core</summary>
            <remarks>
              <para>
                Unlike the normal thread pool, the affine thread pool provides only as many
                threads as there are CPU cores available on the current platform. This makes
                it more suitable for tasks you want to spread across all available cpu cores
                explicitely.
              </para>
              <para>
                However, it's not a good match if you want to run blocking or waiting tasks
                inside the thread pool because the limited available threads will become
                congested quickly. It is encouraged to use this class in parallel with
                .NET's own thread pool, putting tasks that can block into the .NET thread
                pool and task that perform pure processing into the affine thread pool.
              </para>
              <para>
                Implementation based on original code provided by Stephen Toub
                (stoub at microsoft ignorethis dot com)
              </para>
            </remarks>
        </member>
        <member name="F:Nuclex.Support.AffineThreadPool.Processors">
            <summary>Number of CPU cores available on the system</summary>
        </member>
        <member name="M:Nuclex.Support.AffineThreadPool.#cctor">
            <summary>Initializes the thread pool</summary>
        </member>
        <member name="M:Nuclex.Support.AffineThreadPool.QueueUserWorkItem(System.Threading.WaitCallback)">
            <summary>Queues a user work item to the thread pool</summary>
            <param name="callback">
              A WaitCallback representing the delegate to invoke when a thread in the 
              thread pool picks up the work item
            </param>
        </member>
        <member name="M:Nuclex.Support.AffineThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)">
            <summary>Queues a user work item to the thread pool.</summary>
            <param name="callback">
              A WaitCallback representing the delegate to invoke when a thread in the 
              thread pool picks up the work item
            </param>
            <param name="state">
              The object that is passed to the delegate when serviced from the thread pool
            </param>
        </member>
        <member name="M:Nuclex.Support.AffineThreadPool.DefaultExceptionHandler(System.Exception)">
            <summary>
              Default handler used to respond to unhandled exceptions in ThreadPool threads
            </summary>
            <param name="exception">Exception that has occurred</param>
        </member>
        <member name="M:Nuclex.Support.AffineThreadPool.ProcessQueuedItems">
            <summary>A thread worker function that processes items from the work queue</summary>
        </member>
        <member name="M:Nuclex.Support.AffineThreadPool.getNextWorkItem">
            <summary>Obtains the next work item from the queue</summary>
            <returns>The next work item in the queue</returns>
            <remarks>
              If the queue is empty, the call will block until an item is added to
              the queue and the calling thread was the one picking it up.
            </remarks>
        </member>
        <member name="F:Nuclex.Support.AffineThreadPool.ExceptionHandler">
            <summary>Delegate used to handle assertion checks in the code</summary>
        </member>
        <member name="F:Nuclex.Support.AffineThreadPool.hardwareThreads">
            <summary>Available hardware threads the thread pool threads pick from</summary>
        </member>
        <member name="F:Nuclex.Support.AffineThreadPool.userWorkItems">
            <summary>Queue of all the callbacks waiting to be executed.</summary>
        </member>
        <member name="F:Nuclex.Support.AffineThreadPool.workAvailable">
            <summary>
              Used to let the threads in the thread pool wait for new work to appear.
            </summary>
        </member>
        <member name="F:Nuclex.Support.AffineThreadPool.workerThreads">
            <summary>List of all worker threads at the disposal of the thread pool.</summary>
        </member>
        <member name="F:Nuclex.Support.AffineThreadPool.inUseThreads">
            <summary>Number of threads currently active.</summary>
        </member>
        <member name="P:Nuclex.Support.AffineThreadPool.MaxThreads">
            <summary>Gets the number of threads at the disposal of the thread pool</summary>
        </member>
        <member name="P:Nuclex.Support.AffineThreadPool.ActiveThreads">
            <summary>Gets the number of currently active threads in the thread pool</summary>
        </member>
        <member name="P:Nuclex.Support.AffineThreadPool.WaitingWorkItems">
            <summary>
              Gets the number of callback delegates currently waiting in the thread pool
            </summary>
        </member>
        <member name="T:Nuclex.Support.AffineThreadPool.ExceptionDelegate">
            <summary>Delegate used by the thread pool to report unhandled exceptions</summary>
            <param name="exception">Exception that has not been handled</param>
        </member>
        <member name="T:Nuclex.Support.AffineThreadPool.UserWorkItem">
            <summary>Used to hold a callback delegate and the state for that delegate.</summary>
        </member>
        <member name="M:Nuclex.Support.AffineThreadPool.UserWorkItem.#ctor(System.Threading.WaitCallback,System.Object)">
            <summary>Initialize the callback holding object.</summary>
            <param name="callback">Callback delegate for the callback.</param>
            <param name="state">State with which to call the callback delegate.</param>
        </member>
        <member name="F:Nuclex.Support.AffineThreadPool.UserWorkItem.Callback">
            <summary>Callback delegate for the callback.</summary>
        </member>
        <member name="F:Nuclex.Support.AffineThreadPool.UserWorkItem.State">
            <summary>State with which to call the callback delegate.</summary>
        </member>
        <member name="T:Nuclex.Support.EnumHelper">
            <summary>Helper methods for enumerations</summary>
        </member>
        <member name="M:Nuclex.Support.EnumHelper.GetHighestValue``1">
            <summary>Returns the highest value encountered in an enumeration</summary>
            <typeparam name="EnumType">
              Enumeration of which the highest value will be returned
            </typeparam>
            <returns>The highest value in the enumeration</returns>
        </member>
        <member name="M:Nuclex.Support.EnumHelper.GetLowestValue``1">
            <summary>Returns the lowest value encountered in an enumeration</summary>
            <typeparam name="EnumType">
              Enumeration of which the lowest value will be returned
            </typeparam>
            <returns>The lowest value in the enumeration</returns>
        </member>
        <member name="M:Nuclex.Support.EnumHelper.GetValues``1">
            <summary>Retrieves a list of all values contained in an enumeration</summary>
            <typeparam name="EnumType">
              Type of the enumeration whose values will be returned
            </typeparam>
            <returns>All values contained in the specified enumeration</returns>
            <remarks>
              This method produces collectable garbage so it's best to only call it once
              and cache the result.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.EnumHelper.GetValuesXbox360``1">
            <summary>Retrieves a list of all values contained in an enumeration</summary>
            <typeparam name="EnumType">
              Type of the enumeration whose values will be returned
            </typeparam>
            <returns>All values contained in the specified enumeration</returns>
        </member>
        <member name="T:Nuclex.Support.Plugins.PrototypeFactory`2">
            <summary>Factory that creates instances by cloning a prototype</summary>
            <typeparam name="ProductType">Type of product created by the factory</typeparam>
            <typeparam name="ConcreteType">Type of the prototype that will be cloned</typeparam>
        </member>
        <member name="T:Nuclex.Support.Plugins.IAbstractFactory`1">
            <summary>Abstract factory for a concrete type</summary>
            <typeparam name="ProductType">
              Interface or base class of the product of the factory
            </typeparam>
        </member>
        <member name="M:Nuclex.Support.Plugins.IAbstractFactory`1.CreateInstance">
            <summary>
              Creates a new instance of the type to which the factory is specialized
            </summary>
            <returns>The newly created instance</returns>
        </member>
        <member name="T:Nuclex.Support.Plugins.IAbstractFactory">
            <summary>Abstract factory for a concrete type</summary>
        </member>
        <member name="M:Nuclex.Support.Plugins.IAbstractFactory.CreateInstance">
            <summary>
              Creates a new instance of the type to which the factory is specialized
            </summary>
            <returns>The newly created instance</returns>
        </member>
        <member name="M:Nuclex.Support.Plugins.PrototypeFactory`2.#ctor(`1)">
            <summary>Initializes a new prototype based factory</summary>
            <param name="prototype">Prototype instance that will be cloned</param>
        </member>
        <member name="M:Nuclex.Support.Plugins.PrototypeFactory`2.CreateInstance">
            <summary>
              Creates a new instance of the type to which the factory is specialized
            </summary>
            <returns>The newly created instance</returns>
        </member>
        <member name="M:Nuclex.Support.Plugins.PrototypeFactory`2.Nuclex#Support#Plugins#IAbstractFactory#CreateInstance">
            <summary>
              Creates a new instance of the type to which the factory is specialized
            </summary>
            <returns>The newly created instance</returns>
        </member>
        <member name="M:Nuclex.Support.Plugins.PrototypeFactory`2.Dispose">
            <summary>Immediately releases all resources owned by the instance</summary>
        </member>
        <member name="F:Nuclex.Support.Plugins.PrototypeFactory`2.prototype">
            <summary>The prototype object</summary>
        </member>
        <member name="T:Nuclex.Support.Scheduling.ISchedulerService">
            <summary>Service that allows the scheduled invocation of tasks</summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.ISchedulerService.NotifyAt(System.DateTime,System.Threading.WaitCallback)">
            <summary>Schedules a notification at the specified absolute time</summary>
            <param name="notificationTime">
              Absolute time at which the notification will occur
            </param>
            <param name="callback">
              Callback that will be invoked when the notification is due
            </param>
            <returns>A handle that can be used to cancel the notification</returns>
            <remarks>
              The notification is scheduled for the indicated absolute time. If the system
              enters/leaves daylight saving time or the date/time is changed (for example
              when the system synchronizes with an NTP server), this will affect
              the notification. So if you need to be notified after a fixed time, use
              the NotifyIn() method instead.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Scheduling.ISchedulerService.NotifyEach(System.Int32,System.Int32,System.Threading.WaitCallback)">
            <summary>
              Schedules a recurring notification after the specified amount of milliseconds
            </summary>
            <param name="delayMilliseconds">
              Milliseconds after which the first notification will occur
            </param>
            <param name="intervalMilliseconds">
              Interval in milliseconds at which the notification will be repeated
            </param>
            <param name="callback">
              Callback that will be invoked when the notification is due
            </param>
            <returns>A handle that can be used to cancel the notification</returns>
        </member>
        <member name="M:Nuclex.Support.Scheduling.ISchedulerService.NotifyEach(System.TimeSpan,System.TimeSpan,System.Threading.WaitCallback)">
            <summary>
              Schedules a recurring notification after the specified time span
            </summary>
            <param name="delay">Delay after which the first notification will occur</param>
            <param name="interval">Interval at which the notification will be repeated</param>
            <param name="callback">
              Callback that will be invoked when the notification is due
            </param>
            <returns>A handle that can be used to cancel the notification</returns>
        </member>
        <member name="M:Nuclex.Support.Scheduling.ISchedulerService.NotifyIn(System.Int32,System.Threading.WaitCallback)">
            <summary>
              Schedules a notification after the specified amount of milliseconds
            </summary>
            <param name="delayMilliseconds">
              Number of milliseconds after which the notification will occur
            </param>
            <param name="callback">
              Callback that will be invoked when the notification is due
            </param>
            <returns>A handle that can be used to cancel the notification</returns>
        </member>
        <member name="M:Nuclex.Support.Scheduling.ISchedulerService.NotifyIn(System.TimeSpan,System.Threading.WaitCallback)">
            <summary>Schedules a notification after the specified time span</summary>
            <param name="delay">Delay after which the notification will occur</param>
            <param name="callback">
              Callback that will be invoked when the notification is due
            </param>
            <returns>A handle that can be used to cancel the notification</returns>
        </member>
        <member name="M:Nuclex.Support.Scheduling.ISchedulerService.Cancel(System.Object)">
            <summary>Cancels a scheduled notification</summary>
            <param name="notificationHandle">
              Handle of the notification that will be cancelled
            </param>
        </member>
        <member name="P:Nuclex.Support.Scheduling.ISchedulerService.TimeSource">
            <summary>Time source being used by the scheduler</summary>
        </member>
        <member name="T:Nuclex.Support.Scheduling.ITimeSource">
            <summary>Provides time measurement and change notification services</summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.ITimeSource.WaitOne(System.Threading.AutoResetEvent,System.Int64)">
            <summary>Waits for an AutoResetEvent to become signalled</summary>
            <param name="waitHandle">WaitHandle the method will wait for</param>
            <param name="ticks">Number of ticks to wait</param>
            <returns>
              True if the WaitHandle was signalled, false if the timeout was reached
              or the time source thinks its time to recheck the system date/time.
            </returns>
            <remarks>
              Depending on whether the system will provide notifications when date/time
              is adjusted, the time source will be forced to let this method block for
              less than the indicated time before returning a timeout in order to give
              the caller a chance to recheck the system time.
            </remarks>
        </member>
        <member name="E:Nuclex.Support.Scheduling.ITimeSource.DateTimeAdjusted">
            <summary>Called when the system date/time are adjusted</summary>
            <remarks>
              An adjustment is a change out of the ordinary, eg. when a time synchronization
              alters the current system time, when daylight saving time takes effect or
              when the user manually adjusts the system date/time.
            </remarks>
        </member>
        <member name="P:Nuclex.Support.Scheduling.ITimeSource.CurrentUtcTime">
            <summary>Current system time in UTC format</summary>
        </member>
        <member name="P:Nuclex.Support.Scheduling.ITimeSource.Ticks">
            <summary>How long the time source has been running</summary>
            <remarks>
              There is no guarantee this value starts at zero (or anywhere near it) when
              the time source is created. The only requirement for this value is that it
              keeps increasing with the passing of time and that it stays unaffected
              (eg. doesn't skip or jump back) when the system date/time are changed.
            </remarks>
        </member>
        <member name="T:Nuclex.Support.Scheduling.Scheduler">
            <summary>Schedules actions for execution at a future point in time</summary>
            <summary>Schedules actions for execution at a future point in time</summary>
        </member>
        <member name="F:Nuclex.Support.Scheduling.Scheduler.TicksPerMillisecond">
            <summary>One tick is 100 ns, meaning 10000 ticks equal 1 ms</summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.Scheduler.#ctor">
            <summary>Initializes a new scheduler using the default time source</summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.Scheduler.#ctor(Nuclex.Support.Scheduling.ITimeSource)">
            <summary>Initializes a new scheduler using the specified time source</summary>
            <param name="timeSource">Time source the scheduler will use</param>
        </member>
        <member name="M:Nuclex.Support.Scheduling.Scheduler.Dispose">
            <summary>Immediately releases all resources owned by the instance</summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.Scheduler.NotifyAt(System.DateTime,System.Threading.WaitCallback)">
            <summary>Schedules a notification at the specified absolute time</summary>
            <param name="notificationTime">
              Absolute time at which the notification will occur
            </param>
            <param name="callback">
              Callback that will be invoked when the notification is due
            </param>
            <returns>A handle that can be used to cancel the notification</returns>
            <remarks>
              The notification is scheduled for the indicated absolute time. If the system
              enters/leaves daylight saving time or the date/time is changed (for example
              when the system synchronizes with an NTP server), this will affect
              the notification. So if you need to be notified after a fixed time, use
              the NotifyIn() method instead.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Scheduling.Scheduler.NotifyIn(System.TimeSpan,System.Threading.WaitCallback)">
            <summary>Schedules a notification after the specified time span</summary>
            <param name="delay">Delay after which the notification will occur</param>
            <param name="callback">
              Callback that will be invoked when the notification is due
            </param>
            <returns>A handle that can be used to cancel the notification</returns>
        </member>
        <member name="M:Nuclex.Support.Scheduling.Scheduler.NotifyIn(System.Int32,System.Threading.WaitCallback)">
            <summary>
              Schedules a notification after the specified amount of milliseconds
            </summary>
            <param name="delayMilliseconds">
              Number of milliseconds after which the notification will occur
            </param>
            <param name="callback">
              Callback that will be invoked when the notification is due
            </param>
            <returns>A handle that can be used to cancel the notification</returns>
        </member>
        <member name="M:Nuclex.Support.Scheduling.Scheduler.NotifyEach(System.TimeSpan,System.TimeSpan,System.Threading.WaitCallback)">
            <summary>
              Schedules a recurring notification after the specified time span
            </summary>
            <param name="delay">Delay after which the first notification will occur</param>
            <param name="interval">Interval at which the notification will be repeated</param>
            <param name="callback">
              Callback that will be invoked when the notification is due
            </param>
            <returns>A handle that can be used to cancel the notification</returns>
        </member>
        <member name="M:Nuclex.Support.Scheduling.Scheduler.NotifyEach(System.Int32,System.Int32,System.Threading.WaitCallback)">
            <summary>
              Schedules a recurring notification after the specified amount of milliseconds
            </summary>
            <param name="delayMilliseconds">
              Milliseconds after which the first notification will occur
            </param>
            <param name="intervalMilliseconds">
              Interval in milliseconds at which the notification will be repeated
            </param>
            <param name="callback">
              Callback that will be invoked when the notification is due
            </param>
            <returns>A handle that can be used to cancel the notification</returns>
        </member>
        <member name="M:Nuclex.Support.Scheduling.Scheduler.Cancel(System.Object)">
            <summary>Cancels a scheduled notification</summary>
            <param name="notificationHandle">
              Handle of the notification that will be cancelled
            </param>
        </member>
        <member name="M:Nuclex.Support.Scheduling.Scheduler.dateTimeAdjusted(System.Object,System.EventArgs)">
            <summary>Called when the system date/time have been adjusted</summary>
            <param name="sender">Time source which detected the adjustment</param>
            <param name="arguments">Not used</param>
        </member>
        <member name="M:Nuclex.Support.Scheduling.Scheduler.scheduleNotification(Nuclex.Support.Scheduling.Scheduler.Notification)">
            <summary>Schedules a notification for processing by the timer thread</summary>
            <param name="notification">Notification that will be scheduled</param>
            <returns>The scheduled notification</returns>
        </member>
        <member name="M:Nuclex.Support.Scheduling.Scheduler.runTimerThread">
            <summary>Executes the timer thread</summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.Scheduler.getNextDueNotification">
            <summary>Retrieves the notification that is due next</summary>
            <returns>The notification that is due next</returns>
        </member>
        <member name="F:Nuclex.Support.Scheduling.Scheduler.timeSource">
            <summary>Time source used by the scheduler</summary>
        </member>
        <member name="F:Nuclex.Support.Scheduling.Scheduler.timerThread">
            <summary>Thread that will wait for the next scheduled event</summary>
        </member>
        <member name="F:Nuclex.Support.Scheduling.Scheduler.notifications">
            <summary>Notifications in the scheduler's queue</summary>
        </member>
        <member name="F:Nuclex.Support.Scheduling.Scheduler.notificationWaitEvent">
            <summary>Event used by the timer thread to wait for the next notification</summary>
        </member>
        <member name="F:Nuclex.Support.Scheduling.Scheduler.endRequested">
            <summary>Whether the timer thread should end</summary>
        </member>
        <member name="F:Nuclex.Support.Scheduling.Scheduler.dateTimeAdjustedDelegate">
            <summary>Delegate for the dateTimeAdjusted() method</summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.Scheduler.CreateTimeSource(System.Boolean)">
            <summary>Creates a new default time source for the scheduler</summary>
            <param name="useWindowsTimeSource">
              Whether the specialized windows time source should be used
            </param>
            <returns>The newly created time source</returns>
        </member>
        <member name="M:Nuclex.Support.Scheduling.Scheduler.CreateDefaultTimeSource">
            <summary>Creates a new default time source for the scheduler</summary>
            <returns>The newly created time source</returns>
        </member>
        <member name="P:Nuclex.Support.Scheduling.Scheduler.TimeSource">
            <summary>Time source being used by the scheduler</summary>
        </member>
        <member name="P:Nuclex.Support.Scheduling.Scheduler.DefaultTimeSource">
            <summary>Returns the default time source for the scheduler</summary>
        </member>
        <member name="T:Nuclex.Support.Scheduling.Scheduler.Notification">
            <summary>Scheduled notification</summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.Scheduler.Notification.#ctor(System.Int64,System.Int64,System.DateTime,System.Threading.WaitCallback)">
            <summary>Initializes a new notification</summary>
            <param name="intervalTicks">
              Interval in which the notification will re-executed
            </param>
            <param name="nextDueTicks">
              Time source ticks the notification is next due at
            </param>
            <param name="absoluteUtcTime">
              Absolute time in UTC at which the notification is due
            </param>
            <param name="callback">
              Callback to be invoked when the notification is due
            </param>
        </member>
        <member name="F:Nuclex.Support.Scheduling.Scheduler.Notification.IntervalTicks">
            <summary>
              Ticks specifying the interval in which the notification will be re-executed
            </summary>
        </member>
        <member name="F:Nuclex.Support.Scheduling.Scheduler.Notification.NextDueTicks">
            <summary>Next due time for this notification</summary>
        </member>
        <member name="F:Nuclex.Support.Scheduling.Scheduler.Notification.AbsoluteUtcTime">
            <summary>Absolute time in UTC at which the notification is due</summary>
            <remarks>
              Only stored for notifications scheduled in absolute time, meaning they
              have to be adjusted if the system date/time changes
            </remarks>
        </member>
        <member name="F:Nuclex.Support.Scheduling.Scheduler.Notification.Callback">
            <summary>Callback that will be invoked when the notification is due</summary>
        </member>
        <member name="F:Nuclex.Support.Scheduling.Scheduler.Notification.Cancelled">
            <summary>Whether the notification has been cancelled</summary>
        </member>
        <member name="T:Nuclex.Support.Scheduling.Scheduler.NotificationComparer">
            <summary>Compares two notifications to each other</summary>
        </member>
        <member name="F:Nuclex.Support.Scheduling.Scheduler.NotificationComparer.Default">
            <summary>The default instance of the notification comparer</summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.Scheduler.NotificationComparer.Compare(Nuclex.Support.Scheduling.Scheduler.Notification,Nuclex.Support.Scheduling.Scheduler.Notification)">
            <summary>Compares two notifications to each other based on their time</summary>
            <param name="left">Notification that will be compared on the left side</param>
            <param name="right">Notification that will be comapred on the right side</param>
            <returns>The relation of the two notification's times to each other</returns>
        </member>
        <member name="T:Nuclex.Support.Scheduling.Scheduler.TimeSourceSingleton">
            <summary>
              Manages the singleton instance of the scheduler's default time source
            </summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.Scheduler.TimeSourceSingleton.#cctor">
            <summary>
              Explicit static constructor to guarantee the singleton is initialized only
              when a static member of this class is accessed.
            </summary>
        </member>
        <member name="F:Nuclex.Support.Scheduling.Scheduler.TimeSourceSingleton.Instance">
            <summary>The singleton instance of the default time source</summary>
        </member>
        <member name="T:Nuclex.Support.Scheduling.GenericTimeSource">
            <summary>
              Generic time source implementation using the Stopwatch or Environment.TickCount
            </summary>
        </member>
        <member name="F:Nuclex.Support.Scheduling.GenericTimeSource.TicksPerMillisecond">
            <summary>Number of ticks (100 ns intervals) in a millisecond</summary>
        </member>
        <member name="F:Nuclex.Support.Scheduling.GenericTimeSource.TimeAdjustmentToleranceTicks">
            <summary>Tolerance for the detection of a date/time adjustment</summary>
            <remarks>
              If the current system date/time jumps by more than this tolerance into any
              direction, the default time source will trigger the DateTimeAdjusted event.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Scheduling.GenericTimeSource.#cctor">
            <summary>Initializes the static fields of the default time source</summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.GenericTimeSource.#ctor">
            <summary>Initializes the default time source</summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.GenericTimeSource.#ctor(System.Boolean)">
            <summary>Initializes the default time source</summary>
            <param name="useStopwatch">
              Whether to use the Stopwatch class for measuring time
            </param>
            <remarks>
              <para>
                Normally it's a good idea to use the default constructor. If the Stopwatch
                is unable to use the high-resolution timer, it will fall back to
                DateTime.Now (as stated on MSDN). This is bad because then the tick count
                will jump whenever the system time changes (eg. when the system synchronizes
                its time with a time server).
              </para>
              <para>
                Your can safely use this constructor if you always set its arugment to 'false',
                but then your won't profit from the high-resolution timer if one is available.
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Scheduling.GenericTimeSource.WaitOne(System.Threading.AutoResetEvent,System.Int64)">
            <summary>Waits for an AutoResetEvent to become signalled</summary>
            <param name="waitHandle">WaitHandle the method will wait for</param>
            <param name="ticks">Number of ticks to wait</param>
            <returns>
              True if the WaitHandle was signalled, false if the timeout was reached
            </returns>
        </member>
        <member name="M:Nuclex.Support.Scheduling.GenericTimeSource.OnDateTimeAdjusted(System.Object,System.EventArgs)">
            <summary>Called when the system time is changed</summary>
            <param name="sender">Not used</param>
            <param name="arguments">Not used</param>
        </member>
        <member name="M:Nuclex.Support.Scheduling.GenericTimeSource.checkForTimeAdjustment">
            <summary>
              Checks whether the system/date time have been adjusted since the last call
            </summary>
        </member>
        <member name="F:Nuclex.Support.Scheduling.GenericTimeSource.lastCheckedDateTimeTicks">
            <summary>Last local time we checked for a date/time adjustment</summary>
        </member>
        <member name="F:Nuclex.Support.Scheduling.GenericTimeSource.lastCheckedStopwatchTicks">
            <summary>Timer ticks at which we last checked the local time</summary>
        </member>
        <member name="F:Nuclex.Support.Scheduling.GenericTimeSource.tickFrequency">
            <summary>Number of ticks per Stopwatch time unit</summary>
        </member>
        <member name="F:Nuclex.Support.Scheduling.GenericTimeSource.useStopwatch">
            <summary>Whether ot use the Stopwatch class for measuring time</summary>
        </member>
        <member name="E:Nuclex.Support.Scheduling.GenericTimeSource.DateTimeAdjusted">
            <summary>Called when the system date/time are adjusted</summary>
            <remarks>
              An adjustment is a change out of the ordinary, eg. when a time synchronization
              alters the current system time, when daylight saving time takes effect or
              when the user manually adjusts the system date/time.
            </remarks>
        </member>
        <member name="P:Nuclex.Support.Scheduling.GenericTimeSource.CurrentUtcTime">
            <summary>Current system time in UTC format</summary>
        </member>
        <member name="P:Nuclex.Support.Scheduling.GenericTimeSource.Ticks">
            <summary>How long the time source has been running</summary>
            <remarks>
              There is no guarantee this value starts at zero (or anywhere near it) when
              the time source is created. The only requirement for this value is that it
              keeps increasing with the passing of time and that it stays unaffected
              (eg. doesn't skip or jump back) when the system date/time are changed.
            </remarks>
        </member>
        <member name="T:Nuclex.Support.Scheduling.WindowsTimeSource">
            <summary>
              Time source that makes use of additional features only available on Windows
            </summary>
        </member>
        <member name="F:Nuclex.Support.Scheduling.WindowsTimeSource.TicksPerMillisecond">
            <summary>Number of ticks (100 ns intervals) in a millisecond</summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.WindowsTimeSource.#ctor">
            <summary>Initializes a new Windows time source</summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.WindowsTimeSource.Dispose">
            <summary>Immediately releases all resources owned by the instance</summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.WindowsTimeSource.WaitOne(System.Threading.AutoResetEvent,System.Int64)">
            <summary>Waits for an AutoResetEvent to become signalled</summary>
            <param name="waitHandle">WaitHandle the method will wait for</param>
            <param name="ticks">Number of ticks to wait</param>
            <returns>
              True if the WaitHandle was signalled, false if the timeout was reached
            </returns>
        </member>
        <member name="P:Nuclex.Support.Scheduling.WindowsTimeSource.Available">
            <summary>
              Whether the Windows time source can be used on the current platform
            </summary>
        </member>
        <member name="T:Nuclex.Support.Semaphore">
            <summary>A reverse counting semaphore</summary>
            <remarks>
              <para>
                This semaphore counts in reverse, which means you can Release() the semaphore
                as often as you'd like a thread calling WaitOne() to be let through. You
                can use it in the traditional sense and have any Thread calling WaitOne()
                make sure to call Release() afterwards, or you can, for example, Release() it
                whenever work becomes available and let threads take work from the Semaphore
                by calling WaitOne() alone.
              </para>
              <para>
                Implementation notes (ignore this if you just want to use the Semaphore)
              </para>
              <para>
                We could design a semaphore that uses an auto reset event, where the thread
                that gets to pass immediately sets the event again if the semaphore isn't full
                yet to let another thread pass.
              </para>
              <para>
                However, this would mean that when a semaphore receives a large number of
                wait requests, assuming it would allow, for example, 25 users at once, the
                thread scheduler would see only 1 thread become eligible for execution. Then
                that thread would unlock the next and so on. In short, we wait 25 times
                for the thread scheduler to wake up a thread until all users get through.
              </para>
              <para>
                So we chose a ManualResetEvent, which will wake up more threads than
                neccessary and possibly cause a period of intense competition for getting
                a lock on the resource, but will make the thread scheduler see all threads
                become eligible for execution.
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Semaphore.#ctor">
            <summary>Initializes a new semaphore</summary>
        </member>
        <member name="M:Nuclex.Support.Semaphore.#ctor(System.Int32)">
            <summary>Initializes a new semaphore</summary>
            <param name="count">
              Number of users that can access the resource at the same time
            </param>
        </member>
        <member name="M:Nuclex.Support.Semaphore.#ctor(System.Int32,System.Int32)">
            <summary>Initializes a new semaphore</summary>
            <param name="initialCount">
              Initial number of users accessing the resource 
            </param>
            <param name="maximumCount">
              Maximum numbr of users that can access the resource at the same time
            </param>
        </member>
        <member name="M:Nuclex.Support.Semaphore.Dispose(System.Boolean)">
            <summary>Immediately releases all resources owned by the instance</summary>
            <param name="explicitDisposing">
              Whether Dispose() has been called explictly
            </param>
        </member>
        <member name="M:Nuclex.Support.Semaphore.WaitOne(System.Int32,System.Boolean)">
            <summary>
              Waits for the resource to become available and locks it
            </summary>
            <param name="millisecondsTimeout">
              Number of milliseconds to wait at most before giving up
            </param>
            <param name="exitContext">
              True to exit the synchronization domain for the context before the wait (if
              in a synchronized context), and reacquire it afterward; otherwise, false.
            </param>
            <returns>
              True if the resource was available and is now locked, false if
              the timeout has been reached.
            </returns>
        </member>
        <member name="M:Nuclex.Support.Semaphore.WaitOne">
            <summary>
              Waits for the resource to become available and locks it
            </summary>
            <returns>
              True if the resource was available and is now locked, false if
              the timeout has been reached.
            </returns>
        </member>
        <member name="M:Nuclex.Support.Semaphore.Release">
            <summary>
              Releases a lock on the resource. Note that for a reverse counting semaphore,
              it is legal to Release() the resource before locking it.
            </summary>
        </member>
        <member name="M:Nuclex.Support.Semaphore.createEvent">
            <summary>Creates the event used to make threads wait for the resource</summary>
        </member>
        <member name="F:Nuclex.Support.Semaphore.manualResetEvent">
            <summary>Event used to make threads wait if the semaphore is full</summary>
        </member>
        <member name="F:Nuclex.Support.Semaphore.free">
            <summary>Number of users currently accessing the resource</summary>
            <remarks>
              Since this is a reverse counting semaphore, it will be negative if
              the resource is available and 0 if the semaphore is full.
            </remarks>
        </member>
        <member name="T:Nuclex.Support.IO.PartialStream">
            <summary>Wraps a stream and exposes only a limited region of its data</summary>
        </member>
        <member name="M:Nuclex.Support.IO.PartialStream.#ctor(System.IO.Stream,System.Int64,System.Int64)">
            <summary>Initializes a new partial stream</summary>
            <param name="stream">
              Stream the wrapper will make a limited region accessible of
            </param>
            <param name="start">
              Start index in the stream which becomes the beginning for the wrapper
            </param>
            <param name="length">
              Length the wrapped stream should report and allow access to
            </param>
        </member>
        <member name="M:Nuclex.Support.IO.PartialStream.Flush">
            <summary>
              Clears all buffers for this stream and causes any buffered data to be written
              to the underlying device.
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.PartialStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
              Reads a sequence of bytes from the stream and advances the position of
              the file pointer by the number of bytes read.
            </summary>
            <param name="buffer">Buffer that will receive the data read from the stream</param>
            <param name="offset">
              Offset in the buffer at which the stream will place the data read
            </param>
            <param name="count">Maximum number of bytes that will be read</param>
            <returns>
              The number of bytes that were actually read from the stream and written into
              the provided buffer
            </returns>
            <exception cref="T:System.NotSupportedException">
              The wrapped stream does not support reading
            </exception>
        </member>
        <member name="M:Nuclex.Support.IO.PartialStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>Changes the position of the file pointer</summary>
            <param name="offset">
              Offset to move the file pointer by, relative to the position indicated by
              the <paramref name="origin" /> parameter.
            </param>
            <param name="origin">
              Reference point relative to which the file pointer is placed
            </param>
            <returns>The new absolute position within the stream</returns>
        </member>
        <member name="M:Nuclex.Support.IO.PartialStream.SetLength(System.Int64)">
            <summary>Changes the length of the stream</summary>
            <param name="value">New length the stream shall have</param>
            <exception cref="T:System.NotSupportedException">
              Always, the stream chainer does not support the SetLength() operation
            </exception>
        </member>
        <member name="M:Nuclex.Support.IO.PartialStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
              Writes a sequence of bytes to the stream and advances the position of
              the file pointer by the number of bytes written.
            </summary>
            <param name="buffer">
              Buffer containing the data that will be written to the stream
            </param>
            <param name="offset">
              Offset in the buffer at which the data to be written starts
            </param>
            <param name="count">Number of bytes that will be written into the stream</param>
            <remarks>
              The behavior of this method is as follows: If one or more chained streams
              do not support seeking, all data is appended to the final stream in the
              chain. Otherwise, writing will begin with the stream the current file pointer
              offset falls into. If the end of that stream is reached, writing continues
              in the next stream. On the last stream, writing more data into the stream
              that it current size allows will enlarge the stream.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.IO.PartialStream.moveFilePointer(System.Int64)">
            <summary>Moves the file pointer</summary>
            <param name="position">New position the file pointer will be moved to</param>
        </member>
        <member name="M:Nuclex.Support.IO.PartialStream.makeSeekNotSupportedException(System.String)">
            <summary>
              Constructs a NotSupportException for an error caused by the wrapped
              stream having no seek support
            </summary>
            <param name="action">Action that was tried to perform</param>
            <returns>The newly constructed NotSupportedException</returns>
        </member>
        <member name="F:Nuclex.Support.IO.PartialStream.stream">
            <summary>Streams that have been chained together</summary>
        </member>
        <member name="F:Nuclex.Support.IO.PartialStream.start">
            <summary>Start index of the partial stream in the wrapped stream</summary>
        </member>
        <member name="F:Nuclex.Support.IO.PartialStream.position">
            <summary>Zero-based position of the partial stream's file pointer</summary>
            <remarks>
              If the stream does not support seeking, the position will simply be counted
              up until it reaches <see cref="F:Nuclex.Support.IO.PartialStream.length"/>.
            </remarks>
        </member>
        <member name="F:Nuclex.Support.IO.PartialStream.length">
            <summary>Length of the partial stream</summary>
        </member>
        <member name="P:Nuclex.Support.IO.PartialStream.CanRead">
            <summary>Whether data can be read from the stream</summary>
        </member>
        <member name="P:Nuclex.Support.IO.PartialStream.CanSeek">
            <summary>Whether the stream supports seeking</summary>
        </member>
        <member name="P:Nuclex.Support.IO.PartialStream.CanWrite">
            <summary>Whether data can be written into the stream</summary>
        </member>
        <member name="P:Nuclex.Support.IO.PartialStream.Length">
            <summary>Length of the stream in bytes</summary>
            <exception cref="T:System.NotSupportedException">
              The wrapped stream does not support seeking
            </exception>
        </member>
        <member name="P:Nuclex.Support.IO.PartialStream.Position">
            <summary>Absolute position of the file pointer within the stream</summary>
            <exception cref="T:System.NotSupportedException">
              The wrapped stream does not support seeking
            </exception>
        </member>
        <member name="P:Nuclex.Support.IO.PartialStream.CompleteStream">
            <summary>Stream being wrapped by the partial stream wrapper</summary>
        </member>
        <member name="T:Nuclex.Support.IO.RingMemoryStream">
            <summary>Specialized memory stream for ring buffers</summary>
            <remarks>
              This ring buffer class is specialized for binary data and tries to achieve
              optimal efficiency when storing and retrieving chunks of several bytes
              at once. Typical use cases include audio and network buffers where one party
              is responsible for refilling the buffer at regular intervals while the other
              constantly streams data out of it.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.IO.RingMemoryStream.#ctor(System.Int32)">
            <summary>Initializes a new ring memory stream</summary>
            <param name="capacity">Maximum capacity of the stream</param>
        </member>
        <member name="M:Nuclex.Support.IO.RingMemoryStream.Flush">
            <summary>Flushes the buffers and writes down unsaved data</summary>
        </member>
        <member name="M:Nuclex.Support.IO.RingMemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>Reads data from the beginning of the stream</summary>
            <param name="buffer">Buffer in which to store the data</param>
            <param name="offset">Starting index at which to begin writing the buffer</param>
            <param name="count">Number of bytes to read from the stream</param>
            <returns>Die Number of bytes actually read</returns>
        </member>
        <member name="M:Nuclex.Support.IO.RingMemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>Appends data to the end of the stream</summary>
            <param name="buffer">Buffer containing the data to append</param>
            <param name="offset">Starting index of the data in the buffer</param>
            <param name="count">Number of bytes to write to the stream</param>
            <exception cref="T:System.OverflowException">When the ring buffer is full</exception>
        </member>
        <member name="M:Nuclex.Support.IO.RingMemoryStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>Jumps to the specified location within the stream</summary>
            <param name="offset">Position to jump to</param>
            <param name="origin">Origin towards which to interpret the offset</param>
            <returns>The new offset within the stream</returns>
            <exception cref="T:System.NotSupportedException">Always</exception>
        </member>
        <member name="M:Nuclex.Support.IO.RingMemoryStream.SetLength(System.Int64)">
            <summary>Changes the length of the stream</summary>
            <param name="value">New length to resize the stream to</param>
            <exception cref="T:System.NotSupportedException">Always</exception>
        </member>
        <member name="M:Nuclex.Support.IO.RingMemoryStream.setEmpty">
            <summary>Resets the stream to its empty state</summary>
        </member>
        <member name="F:Nuclex.Support.IO.RingMemoryStream.ringBuffer">
            <summary>Internal stream containing the ring buffer data</summary>
        </member>
        <member name="F:Nuclex.Support.IO.RingMemoryStream.startIndex">
            <summary>Start index of the data within the ring buffer</summary>
        </member>
        <member name="F:Nuclex.Support.IO.RingMemoryStream.endIndex">
            <summary>End index of the data within the ring buffer</summary>
        </member>
        <member name="F:Nuclex.Support.IO.RingMemoryStream.empty">
            <summary>Whether the ring buffer is empty</summary>
            <remarks>
              This field is required to differentiate between the ring buffer being
              filled to the limit and being totally empty, because in both cases,
              the start index and the end index will be the same. 
            </remarks>
        </member>
        <member name="P:Nuclex.Support.IO.RingMemoryStream.Capacity">
            <summary>Maximum amount of data that will fit into the ring memory stream</summary>
            <exception cref="T:System.ArgumentOutOfRangeException">
              Thrown if the new capacity is too small for the data already contained
              in the ring buffer.
            </exception>
        </member>
        <member name="P:Nuclex.Support.IO.RingMemoryStream.CanRead">
            <summary>Whether it's possible to read from this stream</summary>
        </member>
        <member name="P:Nuclex.Support.IO.RingMemoryStream.CanSeek">
            <summary>Whether this stream supports random access</summary>
        </member>
        <member name="P:Nuclex.Support.IO.RingMemoryStream.CanWrite">
            <summary>Whether it's possible to write into this stream</summary>
        </member>
        <member name="P:Nuclex.Support.IO.RingMemoryStream.Length">
            <summary>Current length of the stream</summary>
        </member>
        <member name="P:Nuclex.Support.IO.RingMemoryStream.Position">
            <summary>Current cursor position within the stream</summary>
            <exception cref="T:System.NotSupportedException">Always</exception>
        </member>
        <member name="T:Nuclex.Support.Collections.TransformingReadOnlyCollection`2">
            <summary>Collection that transforms the contents of another collection.</summary>
            <typeparam name="ContainedItemType">
              Type of the items contained in the wrapped collection.
            </typeparam>
            <typeparam name="ExposedItemType">
              Type this collection exposes its items as.
            </typeparam>
            <remarks>
              <para>
                This collection is useful if you want to expose the objects of an arbitrary
                collection under a different type. It can be used, for example, to construct
                wrappers for the items in a collection on-the-fly, eliminating the need to
                manage the wrappers in parallel to the real items and improving performance
                by only constructing a wrapper when an item is actually requested.
              </para>
              <para>
                Another common use would be if you have a private collection of a non-public
                type that's derived from some publicly visible type. By using this collection,
                you can return the items under the publicly visible type while still having
                your private collection under the non-public type, eliminating the need to
                downcast each time you need to access elements of the non-public type.
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.#ctor(System.Collections.Generic.IList{`0})">
            <summary>Initializes a new transforming collection wrapper</summary>
            <param name="items">
              Internal list of items that are transformed into the exposed type when
              accessed through the TransformingReadOnlyCollection.
            </param>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.Contains(`1)">
            <summary>
              Determines whether an element is in the TransformingReadOnlyCollection
            </summary>
            <param name="item">
              The object to locate in the TransformingReadOnlyCollection.
              The value can be null for reference types.
            </param>
            <returns>
              True if value is found in the TransformingReadOnlyCollection; otherwise, false.
            </returns>
            <remarks>
              The default implementation of this method is very unoptimized and will
              enumerate all the items in the collection, transforming one after another
              to check whether the transformed item matches the item the user was
              looking for. It is recommended to provide a custom implementation of
              this method, if possible.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.CopyTo(`1[],System.Int32)">
            <summary>
              Copies the entire TransformingReadOnlyCollection to a compatible one-dimensional
              System.Array, starting at the specified index of the target array.
            </summary>
            <param name="array">
              The one-dimensional System.Array that is the destination of the elements copied
              from the TransformingReadOnlyCollection. The System.Array must have
              zero-based indexing.
            </param>
            <param name="index">
              The zero-based index in array at which copying begins.
            </param>
            <exception cref="T:System.ArgumentException">
              Index is equal to or greater than the length of array or the number of elements
              in the source TransformingReadOnlyCollection is greater than the available space
              from index to the end of the destination array.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
              Index is less than zero.
            </exception>
            <exception cref="T:System.ArgumentNullException">
              Array is null.
            </exception>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.GetEnumerator">
            <summary>
              Returns an enumerator that iterates through the TransformingReadOnlyCollection.
            </summary>
            <returns>
              An enumerator or the TransformingReadOnlyCollection.
            </returns>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.IndexOf(`1)">
            <summary>
              Searches for the specified object and returns the zero-based index of the
              first occurrence within the entire TransformingReadOnlyCollection.
            </summary>
            <param name="item">
              The object to locate in the TransformingReadOnlyCollection. The value can
              be null for reference types.
            </param>
            <returns>
              The zero-based index of the first occurrence of item within the entire
              TransformingReadOnlyCollection, if found; otherwise, -1.
            </returns>
            <remarks>
              The default implementation of this method is very unoptimized and will
              enumerate all the items in the collection, transforming one after another
              to check whether the transformed item matches the item the user was
              looking for. It is recommended to provide a custom implementation of
              this method, if possible.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.Transform(`0)">
            <summary>Transforms an item into the exposed type</summary>
            <param name="item">Item to be transformed</param>
            <returns>The transformed item</returns>
            <remarks>
              This method is used to transform an item in the wrapped collection into
              the exposed item type whenever the user accesses an item. Expect it to
              be called frequently, because the TransformingReadOnlyCollection does
              not cache or otherwise store the transformed items.
            </remarks>
        </member>
        <member name="F:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.items">
            <summary>Items being transformed upon exposure by this collection</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.syncRoot">
            <summary>Synchronization root for threaded accesses to this collection</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.System#Collections#Generic#IList{ExposedItemType}#Insert(System.Int32,`1)">
            <summary>
              Inserts an item to the TransformingReadOnlyCollection at the specified index.
            </summary>
            <param name="index">
              The zero-based index at which item should be inserted.
            </param>
            <param name="item">
              The object to insert into the TransformingReadOnlyCollection
            </param>
            <exception cref="T:System.NotSupportedException">
              The TransformingReadOnlyCollection is read-only.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
              index is not a valid index in the TransformingReadOnlyCollection.
            </exception>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.System#Collections#Generic#IList{ExposedItemType}#RemoveAt(System.Int32)">
            <summary>
              Removes the TransformingReadOnlyCollection item at the specified index.
            </summary>
            <param name="index">The zero-based index of the item to remove.</param>
            <exception cref="T:System.NotSupportedException">
              The TransformingReadOnlyCollection is read-only.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
              Index is not a valid index in the TransformingReadOnlyCollection.
            </exception>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.System#Collections#Generic#ICollection{ExposedItemType}#Add(`1)">
            <summary>Adds an item to the TransformingReadOnlyCollection.</summary>
            <param name="item">The object to add to the TransformingReadOnlyCollection</param>
            <exception cref="T:System.NotSupportedException">
              The TransformingReadOnlyCollection is read-only.
            </exception>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.System#Collections#Generic#ICollection{ExposedItemType}#Clear">
            <summary>Removes all items from the TransformingReadOnlyCollection</summary>
            <exception cref="T:System.NotSupportedException">
               The TransformingReadOnlyCollection is read-only.
            </exception>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.System#Collections#Generic#ICollection{ExposedItemType}#Remove(`1)">
            <summary>
              Removes the first occurrence of a specific object from the
              TransformingReadOnlyCollection.
            </summary>
            <param name="item">
              The object to remove from the TransformingReadOnlyCollection
            </param>
            <returns>
              True if item was successfully removed from the TransformingReadOnlyCollection;
              otherwise, false. This method also returns false if item is not found in the
              original TransformingReadOnlyCollection.
            </returns>
            <exception cref="T:System.NotSupportedException">
              The TransformingReadOnlyCollection is read-only.
            </exception>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>Returns an enumerator that iterates through a collection.</summary>
            <returns>
              A System.Collections.IEnumerator object that can be used to iterate through
              the collection.
            </returns>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.System#Collections#IList#Add(System.Object)">
            <summary>Adds an item to the TransformingReadOnlyCollection.</summary>
            <param name="value">
              The System.Object to add to the TransformingReadOnlyCollection.
            </param>
            <returns>The position into which the new element was inserted.</returns>
            <exception cref="T:System.NotSupportedException">
              The System.Collections.IList is read-only or the TransformingReadOnlyCollection
              has a fixed size.
            </exception>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.System#Collections#IList#Clear">
            <summary>Removes all items from the TransformingReadOnlyCollection.</summary>
            <exception cref="T:System.NotSupportedException">
              The TransformingReadOnlyCollection is read-only.
            </exception>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.System#Collections#IList#Contains(System.Object)">
            <summary>
              Determines whether the TransformingReadOnlyCollection contains a specific value.
            </summary>
            <param name="value">
              The System.Object to locate in the TransformingReadOnlyCollection.
            </param>
            <returns>
              True if the System.Object is found in the TransformingReadOnlyCollection;
              otherwise, false.
            </returns>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.System#Collections#IList#IndexOf(System.Object)">
            <summary>
              Determines the index of a specific item in the TransformingReadOnlyCollection.
            </summary>
            <param name="value">
              The System.Object to locate in the TransformingReadOnlyCollection.
            </param>
            <returns>
              The index of value if found in the list; otherwise, -1.
            </returns>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.System#Collections#IList#Insert(System.Int32,System.Object)">
            <summary>
              Inserts an item to the TransformingReadOnlyCollection at the specified index.
            </summary>
            <param name="index">
              The zero-based index at which value should be inserted.
            </param>
            <param name="value">
              The System.Object to insert into the TransformingReadOnlyCollection.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">
              Index is not a valid index in the TransformingReadOnlyCollection.
            </exception>
            <exception cref="T:System.NotSupportedException">
              The System.Collections.IList is read-only or the TransformingReadOnlyCollection
              has a fixed size.
            </exception>
            <exception cref="T:System.NullReferenceException">
              Value is null reference in the TransformingReadOnlyCollection.
            </exception>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.System#Collections#IList#Remove(System.Object)">
            <summary>
              Removes the first occurrence of a specific object from the
              TransformingReadOnlyCollection.
            </summary>
            <param name="value">
              The System.Object to remove from the TransformingReadOnlyCollection.
            </param>
            <exception cref="T:System.NotSupportedException">
              The TransformingReadOnlyCollection is read-only or the
              TransformingReadOnlyCollection has a fixed size.
            </exception>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.System#Collections#IList#RemoveAt(System.Int32)">
            <summary>
              Removes the TransformingReadOnlyCollection item at the specified index.
            </summary>
            <param name="index">The zero-based index of the item to remove.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
              Index is not a valid index in the TransformingReadOnlyCollection.
            </exception>
            <exception cref="T:System.NotSupportedException">
              The TransformingReadOnlyCollection is read-only or the
              TransformingReadOnlyCollection has a fixed size.
            </exception>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>
              Copies the elements of the TransformingReadOnlyCollection to an System.Array,
              starting at a particular System.Array index.
            </summary>
            <param name="array">
              The one-dimensional System.Array that is the destination of the elements
              copied from TransformingReadOnlyCollection. The System.Array must have zero-based
              indexing.
            </param>
            <param name="index">The zero-based index in array at which copying begins.</param>
            <exception cref="T:System.ArgumentNullException">
              Array is null.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
              Index is less than zero.
            </exception>
            <exception cref="T:System.ArgumentException">
              Array is multidimensional or index is equal to or greater than the length
              of array or the number of elements in the source TransformingReadOnlyCollection
              is greater than the available space from index to the end of the destination
              array.
            </exception>
            <exception cref="T:System.InvalidCastException">
              The type of the source TransformingReadOnlyCollection cannot be cast
              automatically to the type of the destination array.
            </exception>
        </member>
        <member name="P:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.Count">
            <summary>
              The number of elements contained in the TransformingReadOnlyCollection instance
            </summary>
        </member>
        <member name="P:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.Item(System.Int32)">
            <summary>Gets the element at the specified index.</summary>
            <param name="index">The zero-based index of the element to get.</param>
            <returns>The element at the specified index.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
               Index is less than zero or index is equal to or greater than
               TransformingReadOnlyCollection.Count.
            </exception>
        </member>
        <member name="P:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.IsReadOnly">
            <summary>Whether the List is write-protected</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.System#Collections#Generic#IList{ExposedItemType}#Item(System.Int32)">
            <summary>Gets or sets the element at the specified index.</summary>
            <param name="index">The zero-based index of the element to get or set.</param>
            <returns>The element at the specified index.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
              Index is not a valid index in the TransformingReadOnlyCollection.
            </exception>
            <exception cref="T:System.NotSupportedException">
              The property is set and the TransformingReadOnlyCollection is read-only
            </exception>
        </member>
        <member name="P:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.System#Collections#IList#IsFixedSize">
            <summary>
              A value indicating whether the TransformingReadOnlyCollection has a fixed
              size.
            </summary>
        </member>
        <member name="P:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.System#Collections#IList#Item(System.Int32)">
            <summary>Gets or sets the element at the specified index.</summary>
            <param name="index">The zero-based index of the element to get or set.</param>
            <returns>The element at the specified index</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
              Index is not a valid index in the TransformingReadOnlyCollection
            </exception>
            <exception cref="T:System.NotSupportedException">
              The property is set and the TransformingReadOnlyCollection is read-only.
            </exception>
        </member>
        <member name="P:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.System#Collections#ICollection#Count">
            <summary>
              The number of elements contained in the TransformingReadOnlyCollection.
            </summary>
        </member>
        <member name="P:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.System#Collections#ICollection#IsSynchronized">
            <summary>
              A value indicating whether access to the TransformingReadOnlyCollection
              is synchronized (thread safe).
            </summary>
        </member>
        <member name="P:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.System#Collections#ICollection#SyncRoot">
            <summary>
              An object that can be used to synchronize access to the
              TransformingReadOnlyCollection.
            </summary>
        </member>
        <member name="T:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.TransformingEnumerator">
            <summary>
              An enumerator that transforms the items returned by an enumerator of the
              wrapped collection into the exposed type on-the-fly.
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.TransformingEnumerator.#ctor(Nuclex.Support.Collections.TransformingReadOnlyCollection{`0,`1},System.Collections.Generic.IEnumerator{`0})">
            <summary>Initializes a new transforming enumerator</summary>
            <param name="transformer">Owner; used to invoke the Transform() method</param>
            <param name="containedTypeEnumerator">Enumerator of the wrapped collection</param>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.TransformingEnumerator.Dispose">
            <summary>Immediately releases all resources used by the instance</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.TransformingEnumerator.MoveNext">
            <summary>Gets the current element in the collection.</summary>
            <returns>The current element in the collection.</returns>
            <exception cref="T:System.InvalidOperationException">
              The enumerator is positioned before the first element of the collection
              or after the last element.
            </exception>
        </member>
        <member name="M:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.TransformingEnumerator.Reset">
            <summary>
              Sets the enumerator to its initial position, which is before the first element
              in the collection.
            </summary>
            <exception cref="T:System.InvalidOperationException">
              The collection was modified after the enumerator was created.
            </exception>
        </member>
        <member name="F:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.TransformingEnumerator.transformer">
            <summary>
              Collection that owns this enumerator; required to invoke the item
              transformation method.
            </summary>
        </member>
        <member name="F:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.TransformingEnumerator.containedTypeEnumerator">
            <summary>An enumerator from the wrapped collection</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.TransformingEnumerator.Current">
            <summary>
              The element in the collection at the current position of the enumerator.
            </summary>
        </member>
        <member name="P:Nuclex.Support.Collections.TransformingReadOnlyCollection`2.TransformingEnumerator.System#Collections#IEnumerator#Current">
            <summary>The current element in the collection.</summary>
            <exception cref="T:System.InvalidOperationException">
              The enumerator is positioned before the first element of the collection
              or after the last element.
            </exception>
        </member>
        <member name="T:Nuclex.Support.Collections.WeakCollection`1">
            <summary>Collection of weakly referenced objects</summary>
            <remarks>
              This collection tries to expose the interface of a normal collection, but stores
              objects as weak references. When an object is accessed, it can return null.
              when the collection detects that one of its items was garbage collected, it
              will silently remove that item.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollection`1.#ctor(System.Collections.Generic.IList{Nuclex.Support.WeakReference{`0}})">
            <summary>Initializes a new weak reference collection</summary>
            <param name="items">
              Internal list of weak references that are unpacking when accessed through
              the WeakCollection's interface.
            </param>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollection`1.#ctor(System.Collections.Generic.IList{Nuclex.Support.WeakReference{`0}},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>Initializes a new weak reference collection</summary>
            <param name="items">
              Internal list of weak references that are unpacking when accessed through
              the WeakCollection's interface.
            </param>
            <param name="comparer">
              Comparer used to identify and compare items to each other
            </param>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollection`1.Contains(`0)">
            <summary>
              Determines whether an element is in the WeakCollection
            </summary>
            <param name="item">
              The object to locate in the WeakCollection. The value can be null.
            </param>
            <returns>
              True if value is found in the WeakCollection; otherwise, false.
            </returns>
            <remarks>
              The default implementation of this method is very unoptimized and will
              enumerate all the items in the collection, transforming one after another
              to check whether the transformed item matches the item the user was
              looking for. It is recommended to provide a custom implementation of
              this method, if possible.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollection`1.CopyTo(`0[],System.Int32)">
            <summary>
              Copies the entire WeakCollection to a compatible one-dimensional
              System.Array, starting at the specified index of the target array.
            </summary>
            <param name="array">
              The one-dimensional System.Array that is the destination of the elements copied
              from the WeakCollection. The System.Array must have zero-based indexing.
            </param>
            <param name="index">
              The zero-based index in array at which copying begins.
            </param>
            <exception cref="T:System.ArgumentException">
              Index is equal to or greater than the length of array or the number of elements
              in the source WeakCollection is greater than the available space from index to
              the end of the destination array.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
              Index is less than zero.
            </exception>
            <exception cref="T:System.ArgumentNullException">
              Array is null.
            </exception>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollection`1.Clear">
            <summary>Removes all items from the WeakCollection</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollection`1.GetEnumerator">
            <summary>
              Returns an enumerator that iterates through the WeakCollection.
            </summary>
            <returns>An enumerator or the WeakCollection.</returns>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollection`1.IndexOf(`0)">
            <summary>
              Searches for the specified object and returns the zero-based index of the
              first occurrence within the entire WeakCollection.
            </summary>
            <param name="item">
              The object to locate in the WeakCollection. The value can
              be null for reference types.
            </param>
            <returns>
              The zero-based index of the first occurrence of item within the entire
              WeakCollection, if found; otherwise, -1.
            </returns>
            <remarks>
              The default implementation of this method is very unoptimized and will
              enumerate all the items in the collection, transforming one after another
              to check whether the transformed item matches the item the user was
              looking for. It is recommended to provide a custom implementation of
              this method, if possible.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollection`1.Remove(`0)">
            <summary>
              Removes the first occurrence of a specific object from the WeakCollection.
            </summary>
            <param name="item">The object to remove from the WeakCollection</param>
            <returns>
              True if item was successfully removed from the WeakCollection; otherwise, false.
            </returns>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollection`1.Add(`0)">
            <summary>Adds an item to the WeakCollection.</summary>
            <param name="item">The object to add to the WeakCollection</param>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollection`1.Insert(System.Int32,`0)">
            <summary>Inserts an item to the WeakCollection at the specified index.</summary>
            <param name="index">
              The zero-based index at which item should be inserted.
            </param>
            <param name="item">The object to insert into the WeakCollection</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
              index is not a valid index in the WeakCollection.
            </exception>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollection`1.RemoveAt(System.Int32)">
            <summary>
              Removes the WeakCollection item at the specified index.
            </summary>
            <param name="index">The zero-based index of the item to remove.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
              Index is not a valid index in the WeakCollection.
            </exception>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollection`1.RemoveDeadItems">
            <summary>
              Removes the items that have been garbage collected from the collection
            </summary>
        </member>
        <member name="F:Nuclex.Support.Collections.WeakCollection`1.items">
            <summary>Weak references to the items contained in the collection</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.WeakCollection`1.comparer">
            <summary>Used to identify and compare items in the collection</summary>
        </member>
        <member name="F:Nuclex.Support.Collections.WeakCollection`1.syncRoot">
            <summary>Synchronization root for threaded accesses to this collection</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollection`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>Returns an enumerator that iterates through a collection.</summary>
            <returns>
              A System.Collections.IEnumerator object that can be used to iterate through
              the collection.
            </returns>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollection`1.System#Collections#IList#Add(System.Object)">
            <summary>Adds an item to the WeakCollection.</summary>
            <param name="value">The System.Object to add to the WeakCollection.</param>
            <returns>The position into which the new element was inserted.</returns>
            <exception cref="T:System.NotSupportedException">
              The System.Collections.IList is read-only or the WeakCollection has a fixed size.
            </exception>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollection`1.System#Collections#IList#Contains(System.Object)">
            <summary>
              Determines whether the WeakCollection contains a specific value.
            </summary>
            <param name="value">The System.Object to locate in the WeakCollection.</param>
            <returns>
              True if the System.Object is found in the WeakCollection; otherwise, false.
            </returns>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollection`1.System#Collections#IList#IndexOf(System.Object)">
            <summary>Determines the index of a specific item in the WeakCollection.</summary>
            <param name="value">The System.Object to locate in the WeakCollection.</param>
            <returns>
              The index of value if found in the list; otherwise, -1.
            </returns>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollection`1.System#Collections#IList#Insert(System.Int32,System.Object)">
            <summary>
              Inserts an item to the WeakCollection at the specified index.
            </summary>
            <param name="index">
              The zero-based index at which value should be inserted.
            </param>
            <param name="value">The System.Object to insert into the WeakCollection.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
              Index is not a valid index in the TransformingReadOnlyCollection.
            </exception>
            <exception cref="T:System.NotSupportedException">
              The System.Collections.IList is read-only or the WeakCollection has a fixed size.
            </exception>
            <exception cref="T:System.NullReferenceException">
              Value is null reference in the WeakCollection.
            </exception>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollection`1.System#Collections#IList#Remove(System.Object)">
            <summary>
              Removes the first occurrence of a specific object from the WeakCollection.
            </summary>
            <param name="value">The System.Object to remove from the WeakCollection.</param>
            <exception cref="T:System.NotSupportedException">
              The WeakCollection is read-only or the WeakCollection has a fixed size.
            </exception>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollection`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>
              Copies the elements of the WeakCollection to an System.Array, starting at
              a particular System.Array index.
            </summary>
            <param name="array">
              The one-dimensional System.Array that is the destination of the elements
              copied from WeakCollection. The System.Array must have zero-based indexing.
            </param>
            <param name="index">The zero-based index in array at which copying begins.</param>
            <exception cref="T:System.ArgumentNullException">
              Array is null.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
              Index is less than zero.
            </exception>
            <exception cref="T:System.ArgumentException">
              Array is multidimensional or index is equal to or greater than the length
              of array or the number of elements in the source WeakCollection is greater than
              the available space from index to the end of the destination array.
            </exception>
            <exception cref="T:System.InvalidCastException">
              The type of the source WeakCollection cannot be cast automatically to the type of
              the destination array.
            </exception>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollection`1.downcastToItemType(System.Object)">
            <summary>
              Downcasts an object reference to a reference to the collection's item type
            </summary>
            <param name="value">Object reference that will be downcast</param>
            <returns>
              The specified object referecne as a reference to the collection's item type
            </returns>
        </member>
        <member name="P:Nuclex.Support.Collections.WeakCollection`1.Count">
            <summary>
              The number of elements contained in the WeakCollection instance
            </summary>
        </member>
        <member name="P:Nuclex.Support.Collections.WeakCollection`1.Item(System.Int32)">
            <summary>Gets the element at the specified index.</summary>
            <param name="index">The zero-based index of the element to get.</param>
            <returns>The element at the specified index.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
               Index is less than zero or index is equal to or greater than
               WeakCollection.Count.
            </exception>
        </member>
        <member name="P:Nuclex.Support.Collections.WeakCollection`1.IsReadOnly">
            <summary>Whether the List is write-protected</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.WeakCollection`1.System#Collections#IList#IsFixedSize">
            <summary>
              A value indicating whether the WeakCollection has a fixed size.
            </summary>
        </member>
        <member name="P:Nuclex.Support.Collections.WeakCollection`1.System#Collections#IList#Item(System.Int32)">
            <summary>Gets or sets the element at the specified index.</summary>
            <param name="index">The zero-based index of the element to get or set.</param>
            <returns>The element at the specified index</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
              Index is not a valid index in the WeakCollection
            </exception>
        </member>
        <member name="P:Nuclex.Support.Collections.WeakCollection`1.System#Collections#ICollection#IsSynchronized">
            <summary>
              A value indicating whether access to the WeakCollection is
              synchronized (thread safe).
            </summary>
        </member>
        <member name="P:Nuclex.Support.Collections.WeakCollection`1.System#Collections#ICollection#SyncRoot">
            <summary>
              An object that can be used to synchronize access to the WeakCollection.
            </summary>
        </member>
        <member name="T:Nuclex.Support.Collections.WeakCollection`1.UnpackingEnumerator">
            <summary>
              An enumerator that unpacks the items returned by an enumerator of the
              weak reference collection into the actual item type on-the-fly.
            </summary>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollection`1.UnpackingEnumerator.#ctor(System.Collections.Generic.IEnumerator{Nuclex.Support.WeakReference{`0}})">
            <summary>Initializes a new unpacking enumerator</summary>
            <param name="containedTypeEnumerator">
              Enumerator of the weak reference collection
            </param>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollection`1.UnpackingEnumerator.Dispose">
            <summary>Immediately releases all resources used by the instance</summary>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollection`1.UnpackingEnumerator.MoveNext">
            <summary>Gets the current element in the collection.</summary>
            <returns>The current element in the collection.</returns>
            <exception cref="T:System.InvalidOperationException">
              The enumerator is positioned before the first element of the collection
              or after the last element.
            </exception>
        </member>
        <member name="M:Nuclex.Support.Collections.WeakCollection`1.UnpackingEnumerator.Reset">
            <summary>
              Sets the enumerator to its initial position, which is before the first element
              in the collection.
            </summary>
            <exception cref="T:System.InvalidOperationException">
              The collection was modified after the enumerator was created.
            </exception>
        </member>
        <member name="F:Nuclex.Support.Collections.WeakCollection`1.UnpackingEnumerator.containedTypeEnumerator">
            <summary>An enumerator from the wrapped collection</summary>
        </member>
        <member name="P:Nuclex.Support.Collections.WeakCollection`1.UnpackingEnumerator.Current">
            <summary>
              The element in the collection at the current position of the enumerator.
            </summary>
        </member>
        <member name="P:Nuclex.Support.Collections.WeakCollection`1.UnpackingEnumerator.System#Collections#IEnumerator#Current">
            <summary>The current element in the collection.</summary>
            <exception cref="T:System.InvalidOperationException">
              The enumerator is positioned before the first element of the collection
              or after the last element.
            </exception>
        </member>
        <member name="T:Nuclex.Support.FloatHelper">
            <summary>Helper routines for working with floating point numbers</summary>
            <remarks>
              <para>
                The floating point comparison code is based on this excellent article:
                http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm
              </para>
              <para>
                "ULP" means Unit in the Last Place and in the context of this library refers to
                the distance between two adjacent floating point numbers. IEEE floating point
                numbers can only represent a finite subset of natural numbers, with greater
                accuracy for smaller numbers and lower accuracy for very large numbers.
              </para>
              <para>
                If a comparison is allowed "2 ulps" of deviation, that means the values are
                allowed to deviate by up to 2 adjacent floating point values, which might be
                as low as 0.0000001 for small numbers or as high as 10.0 for large numbers.
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Support.FloatHelper.AreAlmostEqual(System.Single,System.Single,System.Int32)">
            <summary>Compares two floating point values for equality</summary>
            <param name="left">First floating point value to be compared</param>
            <param name="right">Second floating point value t be compared</param>
            <param name="maxUlps">
              Maximum number of representable floating point values that are allowed to
              be between the left and the right floating point values
            </param>
            <returns>True if both numbers are equal or close to being equal</returns>
            <remarks>
              <para>
                Floating point values can only represent a finite subset of natural numbers.
                For example, the values 2.00000000 and 2.00000024 can be stored in a float,
                but nothing inbetween them.
              </para>
              <para>
                This comparison will count how many possible floating point values are between
                the left and the right number. If the number of possible values between both
                numbers is less than or equal to maxUlps, then the numbers are considered as
                being equal.
              </para>
              <para>
                Implementation partially follows the code outlined here (link now defunct):
                http://www.anttirt.net/2007/08/19/proper-floating-point-comparisons/
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Support.FloatHelper.AreAlmostEqual(System.Double,System.Double,System.Int64)">
            <summary>Compares two double precision floating point values for equality</summary>
            <param name="left">First double precision floating point value to be compared</param>
            <param name="right">Second double precision floating point value t be compared</param>
            <param name="maxUlps">
              Maximum number of representable double precision floating point values that are
              allowed to be between the left and the right double precision floating point values
            </param>
            <returns>True if both numbers are equal or close to being equal</returns>
            <remarks>
              <para>
                Double precision floating point values can only represent a limited series of
                natural numbers. For example, the values 2.0000000000000000 and 2.0000000000000004
                can be stored in a double, but nothing inbetween them.
              </para>
              <para>
                This comparison will count how many possible double precision floating point
                values are between the left and the right number. If the number of possible
                values between both numbers is less than or equal to maxUlps, then the numbers
                are considered as being equal.
              </para>
              <para>
                Implementation partially follows the code outlined here:
                http://www.anttirt.net/2007/08/19/proper-floating-point-comparisons/
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Support.FloatHelper.ReinterpretAsInt(System.Single)">
            <summary>
              Reinterprets the memory contents of a floating point value as an integer value
            </summary>
            <param name="value">
              Floating point value whose memory contents to reinterpret
            </param>
            <returns>
              The memory contents of the floating point value interpreted as an integer
            </returns>
        </member>
        <member name="M:Nuclex.Support.FloatHelper.ReinterpretAsLong(System.Double)">
            <summary>
              Reinterprets the memory contents of a double precision floating point
              value as an integer value
            </summary>
            <param name="value">
              Double precision floating point value whose memory contents to reinterpret
            </param>
            <returns>
              The memory contents of the double precision floating point value
              interpreted as an integer
            </returns>
        </member>
        <member name="M:Nuclex.Support.FloatHelper.ReinterpretAsFloat(System.Int32)">
            <summary>
              Reinterprets the memory contents of an integer as a floating point value
            </summary>
            <param name="value">Integer value whose memory contents to reinterpret</param>
            <returns>
              The memory contents of the integer value interpreted as a floating point value
            </returns>
        </member>
        <member name="M:Nuclex.Support.FloatHelper.ReinterpretAsDouble(System.Int64)">
            <summary>
              Reinterprets the memory contents of an integer value as a double precision
              floating point value
            </summary>
            <param name="value">Integer whose memory contents to reinterpret</param>
            <returns>
              The memory contents of the integer interpreted as a double precision
              floating point value
            </returns>
        </member>
        <member name="T:Nuclex.Support.FloatHelper.FloatIntUnion">
            <summary>Union of a floating point variable and an integer</summary>
        </member>
        <member name="F:Nuclex.Support.FloatHelper.FloatIntUnion.Float">
            <summary>The union's value as a floating point variable</summary>
        </member>
        <member name="F:Nuclex.Support.FloatHelper.FloatIntUnion.Int">
            <summary>The union's value as an integer</summary>
        </member>
        <member name="F:Nuclex.Support.FloatHelper.FloatIntUnion.UInt">
            <summary>The union's value as an unsigned integer</summary>
        </member>
        <member name="T:Nuclex.Support.FloatHelper.DoubleLongUnion">
            <summary>Union of a double precision floating point variable and a long</summary>
        </member>
        <member name="F:Nuclex.Support.FloatHelper.DoubleLongUnion.Double">
            <summary>The union's value as a double precision floating point variable</summary>
        </member>
        <member name="F:Nuclex.Support.FloatHelper.DoubleLongUnion.Long">
            <summary>The union's value as a long</summary>
        </member>
        <member name="F:Nuclex.Support.FloatHelper.DoubleLongUnion.ULong">
            <summary>The union's value as an unsigned long</summary>
        </member>
        <member name="T:Nuclex.Support.IntegerHelper">
            <summary>Helper methods for working with integer types</summary>
        </member>
        <member name="M:Nuclex.Support.IntegerHelper.NextPowerOf2(System.Int64)">
            <summary>Returns the next highest power of 2 from the specified value</summary>
            <param name="value">Value of which to return the next highest power of 2</param>
            <returns>The next highest power of 2 to the value</returns>
        </member>
        <member name="M:Nuclex.Support.IntegerHelper.NextPowerOf2(System.UInt64)">
            <summary>Returns the next highest power of 2 from the specified value</summary>
            <param name="value">Value of which to return the next highest power of 2</param>
            <returns>The next highest power of 2 to the value</returns>
        </member>
        <member name="M:Nuclex.Support.IntegerHelper.NextPowerOf2(System.Int32)">
            <summary>Returns the next highest power of 2 from the specified value</summary>
            <param name="value">Value of which to return the next highest power of 2</param>
            <returns>The next highest power of 2 to the value</returns>
        </member>
        <member name="M:Nuclex.Support.IntegerHelper.NextPowerOf2(System.UInt32)">
            <summary>Returns the next highest power of 2 from the specified value</summary>
            <param name="value">Value of which to return the next highest power of 2</param>
            <returns>The next highest power of 2 to the value</returns>
        </member>
        <member name="T:Nuclex.Support.Licensing.LicenseKey">
            <summary>Typical license key with 5x5 alphanumerical characters</summary>
            <remarks>
              <para>
                This class manages a license key like it is used in Microsoft products.
                Althought it is probably not the exact same technique used by Microsoft,
                the textual representation of the license keys looks identical,
                eg. <code>O809J-RN5TD-IM3CU-4IG1O-O90X9</code>.
              </para>
              <para>
                Available storage space is used efficiently and allows for up to four
                32 bit integers to be stored within the key, that's enough for a full GUID.
                The four integers can be modified directly, for example to store feature
                lists, checksums or other data within the key.
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Licensing.LicenseKey.Parse(System.String)">
            <summary>Parses the license key contained in a string</summary>
            <param name="key">String containing a license key that is to be parsed</param>
            <returns>The license key parsed from provided string</returns>
            <exception cref="T:System.ArgumentException">
              When the provided string is not a license key
            </exception>
        </member>
        <member name="M:Nuclex.Support.Licensing.LicenseKey.#ctor">
            <summary>Initializes a new, empty license key</summary>
        </member>
        <member name="M:Nuclex.Support.Licensing.LicenseKey.#ctor(System.Guid)">
            <summary>Initializes the license key from a GUID</summary>
            <param name="source">GUID that is used to create the license key</param>
        </member>
        <member name="M:Nuclex.Support.Licensing.LicenseKey.ToGuid">
            <summary>Converts the license key into a GUID</summary>
            <returns>The GUID created from the license key</returns>
        </member>
        <member name="M:Nuclex.Support.Licensing.LicenseKey.ToByteArray">
            <summary>Converts the license key into a byte array</summary>
            <returns>A byte array containing the converted license key</returns>
        </member>
        <member name="M:Nuclex.Support.Licensing.LicenseKey.ToString">
            <summary>Converts the license key to a string</summary>
            <returns>A string containing the converted license key</returns>
        </member>
        <member name="M:Nuclex.Support.Licensing.LicenseKey.mangle(System.Collections.BitArray)">
            <summary>Mangles a bit array</summary>
            <param name="bits">Bit array that will be mangled</param>
        </member>
        <member name="M:Nuclex.Support.Licensing.LicenseKey.unmangle(System.Collections.BitArray)">
            <summary>Unmangles a bit array</summary>
            <param name="bits">Bit array that will be unmangled</param>
        </member>
        <member name="F:Nuclex.Support.Licensing.LicenseKey.keyDelimiter">
            <summary>Character used to delimit each 5 digit group in a license key</summary>
            <remarks>
              Required to be a char array because the .NET Compact Framework only provides
              an overload for char[] in the StringBuilder.Insert() method.
            </remarks>
        </member>
        <member name="F:Nuclex.Support.Licensing.LicenseKey.codeTable">
            <summary>Table with the individual characters in a key</summary>
        </member>
        <member name="F:Nuclex.Support.Licensing.LicenseKey.powersOfTwo">
            <summary>Helper array containing the precalculated powers of two</summary>
        </member>
        <member name="F:Nuclex.Support.Licensing.LicenseKey.shuffle">
            <summary>Index list for rotating the bit arrays</summary>
        </member>
        <member name="F:Nuclex.Support.Licensing.LicenseKey.guid">
            <summary>GUID in which the key is stored</summary>
        </member>
        <member name="P:Nuclex.Support.Licensing.LicenseKey.Item(System.Int32)">
            <summary>Accesses the four integer values within a license key</summary>
            <exception cref="T:System.IndexOutOfRangeException">
              When the index lies outside of the key's fields
            </exception>
        </member>
        <member name="T:Nuclex.Support.Parsing.CommandLine">
            <summary>Parses and stores an application's command line parameters</summary>
            <remarks>
              <para>
                At the time of the creation of this component, there are already several command
                line parsing libraries out there. Most of them, however, do way too much at once
                or at the very least rely on huge, untested clutters of classes and methods to
                arrive at their results.
              </para>
              <para>
                This command line parser does nothing more than represent the command line to
                the application through a convenient interface. It parses a command line and
                extracts the arguments, but doesn't interpret them and or check them for validity.
              </para>
              <para>
                This design promotes simplicity and makes is an ideal building block to create
                actual command line interpreters that connect the parameters to program
                instructions and or fill structures in code.
              </para>
              <para>
                Terminology
                <list type="table">
                  <item>
                    <term>Command line</term>
                    <description>
                      The entire command line either as a string or as
                      an already parsed data structure
                    </description>
                  </item>
                  <item>
                    <term>Argument</term>
                    <description>
                      Either an option or a loose value (see below) being specified on
                      the command line
                    </description>
                  </item>
                  <item>
                    <term>Option</term>
                    <description>
                      Can be specified on the command line and typically alters the behavior
                      of the application or changes a setting. For example, '--normalize' or
                      '/safemode'.
                    </description>
                  </item>
                  <item>
                    <term>Value</term>
                    <description>
                      Can either sit loosely in the command line (eg. 'update' or 'textfile.txt')
                      or as assignment to an option (eg. '--width=1280' or '/overwrite:always')
                    </description>
                  </item>
                </list>
              </para>
            </remarks>
        </member>
        <member name="F:Nuclex.Support.Parsing.CommandLine.WindowsModeDefault">
            <summary>
              Whether the command line should use Windows mode by default
            </summary>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.#ctor">
            <summary>Initializes a new command line</summary>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.#ctor(System.Boolean)">
            <summary>Initializes a new command line</summary>
            <param name="windowsMode">Whether the / character initiates an argument</param>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.#ctor(System.Collections.Generic.List{Nuclex.Support.Parsing.CommandLine.Argument})">
            <summary>Initializes a new command line</summary>
            <param name="argumentList">List containing the parsed arguments</param>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.#ctor(System.Collections.Generic.List{Nuclex.Support.Parsing.CommandLine.Argument},System.Boolean)">
            <summary>Initializes a new command line</summary>
            <param name="argumentList">List containing the parsed arguments</param>
            <param name="windowsMode">Whether the / character initiates an argument</param>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.Parse(System.String)">
            <summary>Parses the command line arguments from the provided string</summary>
            <param name="commandLineString">String containing the command line arguments</param>
            <returns>The parsed command line</returns>
            <remarks>
              You should always pass Environment.CommandLine to this method to avoid
              some problems with the built-in command line tokenizer in .NET
              (which splits '--test"hello world"/v' into '--testhello world/v')
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.Parse(System.String,System.Boolean)">
            <summary>Parses the command line arguments from the provided string</summary>
            <param name="commandLineString">String containing the command line arguments</param>
            <param name="windowsMode">Whether the / character initiates an argument</param>
            <returns>The parsed command line</returns>
            <remarks>
              You should always pass Environment.CommandLine to this methods to avoid
              some problems with the built-in command line tokenizer in .NET
              (which splits '--test"hello world"/v' into '--testhello world/v')
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.HasArgument(System.String)">
            <summary>Returns whether an argument with the specified name exists</summary>
            <param name="name">Name of the argument whose existence will be checked</param>
            <returns>True if an argument with the specified name exists</returns>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.AddValue(System.String)">
            <summary>Adds a value to the command line</summary>
            <param name="value">Value that will be added</param>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.AddOption(System.String)">
            <summary>Adds an option to the command line</summary>
            <param name="name">Name of the option that will be added</param>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.AddOption(System.String,System.String)">
            <summary>Adds an option to the command line</summary>
            <param name="initiator">Initiator that will be used to start the option</param>
            <param name="name">Name of the option that will be added</param>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.AddAssignment(System.String,System.String)">
            <summary>Adds an option with an assignment to the command line</summary>
            <param name="name">Name of the option that will be added</param>
            <param name="value">Value that will be assigned to the option</param>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.AddAssignment(System.String,System.String,System.String)">
            <summary>Adds an option with an assignment to the command line</summary>
            <param name="initiator">Initiator that will be used to start the option</param>
            <param name="name">Name of the option that will be added</param>
            <param name="value">Value that will be assigned to the option</param>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.ToString">
            <summary>Returns a string that contains the entire command line</summary>
            <returns>The entire command line as a single string</returns>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.indexOfArgument(System.String)">
            <summary>Retrieves the index of the argument with the specified name</summary>
            <param name="name">Name of the argument whose index will be returned</param>
            <returns>
              The index of the indicated argument of -1 if no argument with that name exists
            </returns>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.requiresQuotes(System.String)">
            <summary>
              Determines whether the string requires quotes to survive the command line
            </summary>
            <param name="value">Value that will be checked for requiring quotes</param>
            <returns>True if the value requires quotes to survive the command line</returns>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.containsWhitespace(System.String)">
            <summary>
              Determines whether the string contains any whitespace characters
            </summary>
            <param name="value">String that will be scanned for whitespace characters</param>
            <returns>True if the provided string contains whitespace characters</returns>
        </member>
        <member name="F:Nuclex.Support.Parsing.CommandLine.arguments">
            <summary>Options that were specified on the command line</summary>
        </member>
        <member name="F:Nuclex.Support.Parsing.CommandLine.windowsMode">
            <summary>Whether the / character initiates an argument</summary>
        </member>
        <member name="P:Nuclex.Support.Parsing.CommandLine.Arguments">
            <summary>Options that were specified on the command line</summary>
        </member>
        <member name="T:Nuclex.Support.Parsing.CommandLine.Argument">
            <summary>Argument being specified on an application's command line</summary>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.Argument.OptionOnly(Nuclex.Support.StringSegment,System.Int32,System.Int32)">
            <summary>Initializes a new option with only a name</summary>
            <param name="raw">
              String segment with the entire argument as it was given on the command line
            </param>
            <param name="nameStart">Absolute index the argument name starts at</param>
            <param name="nameLength">Number of characters in the option name</param>
            <returns>The newly created option</returns>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.Argument.ValueOnly(Nuclex.Support.StringSegment,System.Int32,System.Int32)">
            <summary>Initializes a new argument with only a value</summary>
            <param name="raw">
              String segment with the entire argument as it was given on the command line
            </param>
            <param name="valueStart">Absolute index the value starts at</param>
            <param name="valueLength">Number of characters in the value</param>
            <returns>The newly created option</returns>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.Argument.#ctor(Nuclex.Support.StringSegment,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>Creates a new option with a name and an assigned value</summary>
            <param name="raw">
              String segment containing the entire option as it was given on the command line
            </param>
            <param name="nameStart">Absolute index the option name starts at</param>
            <param name="nameLength">Number of characters in the option name</param>
            <param name="valueStart">Absolute index the value starts at</param>
            <param name="valueLength">Number of characters in the value</param>
            <returns>The newly created option</returns>
        </member>
        <member name="F:Nuclex.Support.Parsing.CommandLine.Argument.raw">
            <summary>
              Contains the entire option as it was specified on the command line
            </summary>
        </member>
        <member name="F:Nuclex.Support.Parsing.CommandLine.Argument.nameStart">
            <summary>Absolute index in the raw string the option name starts at</summary>
        </member>
        <member name="F:Nuclex.Support.Parsing.CommandLine.Argument.nameLength">
            <summary>Number of characters in the option name</summary>
        </member>
        <member name="F:Nuclex.Support.Parsing.CommandLine.Argument.valueStart">
            <summary>Absolute index in the raw string the value starts at</summary>
        </member>
        <member name="F:Nuclex.Support.Parsing.CommandLine.Argument.valueLength">
            <summary>Number of characters in the value</summary>
        </member>
        <member name="P:Nuclex.Support.Parsing.CommandLine.Argument.Raw">
            <summary>Contains the raw string the command line argument was parsed from</summary>
        </member>
        <member name="P:Nuclex.Support.Parsing.CommandLine.Argument.Initiator">
            <summary>Characters used to initiate this option</summary>
        </member>
        <member name="P:Nuclex.Support.Parsing.CommandLine.Argument.Name">
            <summary>Name of the command line option</summary>
        </member>
        <member name="P:Nuclex.Support.Parsing.CommandLine.Argument.Associator">
            <summary>Characters used to associate a value to this option</summary>
        </member>
        <member name="P:Nuclex.Support.Parsing.CommandLine.Argument.Value">
            <summary>Name of the command line option</summary>
        </member>
        <member name="P:Nuclex.Support.Parsing.CommandLine.Argument.RawLength">
            <summary>The raw length of the command line argument</summary>
        </member>
        <member name="T:Nuclex.Support.Parsing.CommandLine.Formatter">
            <summary>Formats a command line instance into a string</summary>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.Formatter.FormatCommandLine(Nuclex.Support.Parsing.CommandLine)">
            <summary>
              Formats all arguments in the provided command line instance into a string
            </summary>
            <param name="commandLine">Command line instance that will be formatted</param>
            <returns>All arguments in the command line instance as a string</returns>
        </member>
        <member name="T:Nuclex.Support.Parsing.CommandLine.Parser">
            <summary>Parses command line strings</summary>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.Parser.#ctor(System.Boolean)">
            <summary>Initializes a new command line parser</summary>
            <param name="windowsMode">Whether the / character initiates an argument</param>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.Parser.Parse(System.String,System.Boolean)">
            <summary>Parses a string containing command line arguments</summary>
            <param name="commandLineString">String that will be parsed</param>
            <param name="windowsMode">Whether the / character initiates an argument</param>
            <returns>The parsed command line arguments from the string</returns>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.Parser.parseFullCommandLine(System.String)">
            <summary>
              Parses the provided string and adds the parameters found to
              the command line representation
            </summary>
            <param name="commandLineString">
              String containing the command line arguments that will be parsed
            </param>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.Parser.parseChunk(System.String,System.Int32@)">
            <summary>
              Parses a chunk of characters and adds it as an option or a loose value to
              the command line representation we're building
            </summary>
            <param name="commandLineString">
              String containing the chunk of characters that will be parsed
            </param>
            <param name="index">Index in the string at which to begin parsing</param>
            <returns>The number of characters that were consumed</returns>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.Parser.parsePotentialOption(System.String,System.Int32,System.Int32@)">
            <summary>Parses a potential command line option</summary>
            <param name="commandLineString">String containing the command line arguments</param>
            <param name="initiatorStartIndex">
              Index of the option's initiator ('-' or '--' or '/')
            </param>
            <param name="index">
              Index at which the option name is supposed start (if it's an actual option)
            </param>
            <returns>The number of characters consumed</returns>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.Parser.parsePotentialOptionAssignment(System.String,System.Int32,System.Int32,System.Int32@)">
            <summary>Parses the value assignment in a command line option</summary>
            <param name="commandLineString">String containing the command line arguments</param>
            <param name="initiatorStartIndex">
              Position of the character that started the option
            </param>
            <param name="nameStartIndex">
              Position of the first character in the option's name
            </param>
            <param name="index">Index at which the option name ended</param>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.Parser.parseOptionValue(System.String,System.Int32,System.Int32,System.Int32@)">
            <summary>Parses the value assignment in a command line option</summary>
            <param name="commandLineString">String containing the command line arguments</param>
            <param name="initiatorStartIndex">
              Position of the character that started the option
            </param>
            <param name="nameStartIndex">
              Position of the first character in the option's name
            </param>
            <param name="index">Index at which the option name ended</param>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.Parser.parseQuotedValue(System.String,System.Int32@)">
            <summary>Parses a quoted value from the input string</summary>
            <param name="commandLineString">String the quoted value is parsed from</param>
            <param name="index">Index at which the quoted value begins</param>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.Parser.parseNakedValue(System.String,System.Int32@)">
            <summary>Parses a plain, unquoted value from the input string</summary>
            <param name="commandLineString">String containing the value to be parsed</param>
            <param name="index">Index at which the value begins</param>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.Parser.addValue(Nuclex.Support.StringSegment)">
            <summary>Adds a loose value to the command line</summary>
            <param name="value">Value taht will be added</param>
        </member>
        <member name="M:Nuclex.Support.Parsing.CommandLine.Parser.isAssignmentCharacter(System.Char)">
            <summary>
              Determines whether the specified character indicates an assignment
            </summary>
            <param name="character">
              Character that will be checked for being an assignemnt
            </param>
            <returns>
              True if the specified character indicated an assignment, otherwise false
            </returns>
        </member>
        <member name="F:Nuclex.Support.Parsing.CommandLine.Parser.NameEndingCharacters">
            <summary>Characters which end an option name when they are encountered</summary>
        </member>
        <member name="F:Nuclex.Support.Parsing.CommandLine.Parser.WhitespaceCharacters">
            <summary>Characters the parser considers to be whitespace</summary>
        </member>
        <member name="F:Nuclex.Support.Parsing.CommandLine.Parser.arguments">
            <summary>Argument list being filled by the parser</summary>
        </member>
        <member name="F:Nuclex.Support.Parsing.CommandLine.Parser.windowsMode">
            <summary>Whether the '/' character initiates an argument</summary>
        </member>
        <member name="T:Nuclex.Support.PathHelper">
            <summary>Utility class for path operations</summary>
        </member>
        <member name="M:Nuclex.Support.PathHelper.MakeRelative(System.String,System.String)">
            <summary>Converts an absolute path into a relative one</summary>
            <param name="basePath">Base directory the new path should be relative to</param>
            <param name="absolutePath">Absolute path that will be made relative</param>
            <returns>
              A path relative to the indicated base directory that matches the
              absolute path given.
            </returns>
        </member>
        <member name="T:Nuclex.Support.Plugins.AssemblyLoadEventHandler">
            <summary>Signature for the AssemblyLoad event</summary>
            <param name="sender">Object that is reporting that an assembly was loaded</param>
            <param name="arguments">Contains the loaded assembly</param>
        </member>
        <member name="T:Nuclex.Support.Plugins.AssemblyLoadEventArgs">
            <summary>Argument container for the AssemblyLoad event arguments</summary>
        </member>
        <member name="M:Nuclex.Support.Plugins.AssemblyLoadEventArgs.#ctor(System.Reflection.Assembly)">
            <summary>Initializes a new event argument container</summary>
            <param name="loadedAssembly">Assembly that has been loaded</param>
        </member>
        <member name="F:Nuclex.Support.Plugins.AssemblyLoadEventArgs.loadedAssembly">
            <summary>Loaded assembly that will be provided to the event receivers</summary>
        </member>
        <member name="P:Nuclex.Support.Plugins.AssemblyLoadEventArgs.LoadedAssembly">
            <summary>Assembly that was loaded by the sender of the event</summary>
        </member>
        <member name="T:Nuclex.Support.Plugins.IAssemblyLoader">
            <summary>Interface for an assembly loading helper</summary>
        </member>
        <member name="M:Nuclex.Support.Plugins.IAssemblyLoader.TryLoadFile(System.String,System.Reflection.Assembly@)">
            <summary>Tries to loads an assembly from a file</summary>
            <param name="path">Path to the file that is loaded as an assembly</param>
            <param name="loadedAssembly">
              Output parameter that receives the loaded assembly or null
            </param>
            <returns>True if the assembly was loaded successfully, otherwise false</returns>
        </member>
        <member name="T:Nuclex.Support.Plugins.NoPluginAttribute">
            <summary>Attribute that prevents a class from being seen by the PluginHost</summary>
            <remarks>
              When this attribute is attached to a class it will be invisible to the
              PluginHost and not become accessable as a plugin.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Plugins.NoPluginAttribute.#ctor">
            <summary>Initializes an instance of the NoPluginAttributes</summary>
        </member>
        <member name="T:Nuclex.Support.Plugins.Employer">
            <summary>Plugin type employer</summary>
            <remarks>
              This class is used by the plugin host to assess whether a concrete type found
              in a plugin assembly is suited to be processed the plugin user. If so,
              the employer can employ the type. Employing can typically mean to create an
              instance of the type in the plugin assembly or to build a runtime-factory
              that can create instances of the type when it is needed.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Plugins.Employer.CanEmploy(System.Type)">
            <summary>Determines whether the type suites the employer's requirements</summary>
            <param name="type">Type which will be assessed</param>
            <returns>True if the type can be employed, otherwise false</returns>
        </member>
        <member name="M:Nuclex.Support.Plugins.Employer.Employ(System.Type)">
            <summary>Employs the specified plugin type</summary>
            <param name="type">Type to be employed</param>
        </member>
        <member name="T:Nuclex.Support.Plugins.FactoryEmployer`1">
            <summary>Employer to create factories of suiting types found in plugins</summary>
            <typeparam name="ProductType">
              Interface or base class that the types need to implement
            </typeparam>
            <remarks>
              <para>
                This employer will not directly instanciate any compatible types found in
                plugin assemblies, but generated runtime-factories of these types, enabling the
                user to decide when and how many instances of a type will be created.
              </para>
              <para>
                This approach has the advantage that it enables even assemblies that were not
                intended to be plugins can be loaded as plugins, without risking an instanciation
                or complex and possibly heavy-weight types. The disadvantage is that the
                runtime-factory can not provide decent informationa about the plugin type like
                a human-readable name, capabilities or an icon.
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Plugins.FactoryEmployer`1.#ctor">
            <summary>Initializes a new FactoryEmployer</summary>
        </member>
        <member name="M:Nuclex.Support.Plugins.FactoryEmployer`1.CanEmploy(System.Type)">
            <summary>Determines whether the type suites the employer's requirements</summary>
            <param name="type">Type which will be assessed</param>
            <returns>True if the type can be employed</returns>
        </member>
        <member name="M:Nuclex.Support.Plugins.FactoryEmployer`1.Employ(System.Type)">
            <summary>Employs the specified plugin type</summary>
            <param name="type">Type to be employed</param>
        </member>
        <member name="F:Nuclex.Support.Plugins.FactoryEmployer`1.employedFactories">
            <summary>All factories that the instance employer has created</summary>
        </member>
        <member name="P:Nuclex.Support.Plugins.FactoryEmployer`1.Factories">
            <summary>List of all factories that the instance employer has created</summary>
        </member>
        <member name="T:Nuclex.Support.Plugins.FactoryEmployer`1.ConcreteFactory">
            <summary>Concrete factory for the types in a plugin assembly</summary>
        </member>
        <member name="M:Nuclex.Support.Plugins.FactoryEmployer`1.ConcreteFactory.#ctor(System.Type)">
            <summary>
              Initializes a factory and configures it for the specified product
            </summary>
            <param name="type">Type of which the factory creates instances</param>
        </member>
        <member name="M:Nuclex.Support.Plugins.FactoryEmployer`1.ConcreteFactory.CreateInstance">
            <summary>Create a new instance of the type the factory is configured to</summary>
            <returns>The newly created instance</returns>
        </member>
        <member name="M:Nuclex.Support.Plugins.FactoryEmployer`1.ConcreteFactory.Nuclex#Support#Plugins#IAbstractFactory#CreateInstance">
            <summary>Create a new instance of the type the factory is configured to</summary>
            <returns>The newly created instance</returns>
        </member>
        <member name="F:Nuclex.Support.Plugins.FactoryEmployer`1.ConcreteFactory.concreteType">
            <summary>Concrete product which the factory instance creates</summary>
        </member>
        <member name="T:Nuclex.Support.Plugins.InstanceEmployer`1">
            <summary>Employer that directly creates instances of the types in a plugin</summary>
            <typeparam name="T">Interface or base class required for the employed types</typeparam>
            <remarks>
              <para>
                This employer directly creates an instance of any type in a plugin assembly that
                implements or is derived from the type the generic InstanceEmployer is instanced
                to. This is useful when the plugin user already has a special plugin interface
                through which additional informations about a plugin type can be queried or
                when actually exactly one instance per plugin type is wanted (think of the
                prototype pattern for example)
              </para>
              <para>
                Because this employer blindly creates an instance of any compatible type found
                in a plugin assembly it should be used with care. If big types with high
                construction time or huge memory requirements are loaded this can become
                a real resource hog. The intention of this employer was to let the plugin user
                define his own factory interface which possibly provides further details about
                the type the factory is reponsible for (like a description field). This
                factory would then be implemented on the plugin side.
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Plugins.InstanceEmployer`1.#ctor">
            <summary>Initializes a new instance employer</summary>
        </member>
        <member name="M:Nuclex.Support.Plugins.InstanceEmployer`1.CanEmploy(System.Type)">
            <summary>Determines whether the type suites the employer's requirements</summary>
            <param name="type">Type that is checked for employability</param>
            <returns>True if the type can be employed</returns>
        </member>
        <member name="M:Nuclex.Support.Plugins.InstanceEmployer`1.Employ(System.Type)">
            <summary>Employs the specified plugin type</summary>
            <param name="type">Type to be employed</param>
        </member>
        <member name="F:Nuclex.Support.Plugins.InstanceEmployer`1.employedInstances">
            <summary>All instances employed by the instance employer</summary>
        </member>
        <member name="P:Nuclex.Support.Plugins.InstanceEmployer`1.Instances">
            <summary>All instances that have been employed</summary>
        </member>
        <member name="T:Nuclex.Support.Plugins.PluginHelper">
            <summary>Supporting functions for the plugin classes</summary>
        </member>
        <member name="M:Nuclex.Support.Plugins.PluginHelper.HasDefaultConstructor(System.Type)">
            <summary>Determines whether the given type has a default constructor</summary>
            <param name="type">Type which is to be checked</param>
            <returns>True if the type has a default constructor</returns>
        </member>
        <member name="T:Nuclex.Support.Plugins.PluginHost">
            <summary>Integration host for plugins</summary>
            <remarks>
              This class is created by the party that is interested in loading plugins,
              herein referred to as the "plugin user". The plugin host will monitor a
              repository and react to any assembly being loaded into that repository by
              iterating over all types (as in classes and structures) found in the
              assembly and using the employer to do whatever the plugin user intends 
              to do with the types found in that assembly
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Plugins.PluginHost.#ctor(Nuclex.Support.Plugins.Employer)">
            <summary>Initializes a plugin host using a new repository</summary>
            <param name="employer">Employer used assess and employ the plugin types</param>
        </member>
        <member name="M:Nuclex.Support.Plugins.PluginHost.#ctor(Nuclex.Support.Plugins.Employer,Nuclex.Support.Plugins.PluginRepository)">
            <summary>Initializes the plugin using an existing repository</summary>
            <param name="employer">Employer used assess and employ the plugin types</param>
            <param name="repository">Repository in which plugins will be stored</param>
        </member>
        <member name="M:Nuclex.Support.Plugins.PluginHost.assemblyLoadHandler(System.Object,Nuclex.Support.Plugins.AssemblyLoadEventArgs)">
            <summary>Responds to a new plugin being loaded into the repository</summary>
            <param name="sender">Repository into which the assembly was loaded</param>
            <param name="arguments">Event arguments; contains the loaded assembly</param>
        </member>
        <member name="M:Nuclex.Support.Plugins.PluginHost.employAssemblyTypes(System.Reflection.Assembly)">
            <summary>Employs all employable types in an assembly</summary>
            <param name="assembly">Assembly whose types to assess and to employ</param>
        </member>
        <member name="M:Nuclex.Support.Plugins.PluginHost.containsNoPluginAttribute(System.Object[])">
            <summary>
              Determines whether the specifies list of attributes contains a NoPluginAttribute
            </summary>
            <param name="attributes">List of attributes to check</param>
            <returns>True if the list contained a NoPluginAttribute, false otherwise</returns>
        </member>
        <member name="M:Nuclex.Support.Plugins.PluginHost.reportError(System.String)">
            <summary>Reports an error to the debugging console</summary>
            <param name="error">Error message that will be reported</param>
        </member>
        <member name="F:Nuclex.Support.Plugins.PluginHost.employer">
            <summary>Employs and manages types in the loaded plugin assemblies</summary>
        </member>
        <member name="F:Nuclex.Support.Plugins.PluginHost.repository">
            <summary>Repository containing all plugins loaded, shared with other hosts</summary>
        </member>
        <member name="P:Nuclex.Support.Plugins.PluginHost.Repository">
            <summary>The repository containing all loaded plugins</summary>
        </member>
        <member name="P:Nuclex.Support.Plugins.PluginHost.Employer">
            <summary>The employer that is used by this plugin integration host</summary>
        </member>
        <member name="T:Nuclex.Support.Plugins.PluginRepository">
            <summary>Stores loaded plugins</summary>
            <remarks>
              This class manages a set of assemblies that have been dynamically loaded 
              as plugins. It usually is shared by multiple PluginHosts that handle
              different interfaces of one plugin type.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Plugins.PluginRepository.#ctor">
            <summary>Initializes a new instance of the plugin repository</summary>
        </member>
        <member name="M:Nuclex.Support.Plugins.PluginRepository.#ctor(Nuclex.Support.Plugins.IAssemblyLoader)">
            <summary>Initializes a new instance of the plugin repository</summary>
            <param name="loader">
              Loader to use for loading assemblies into this repository
            </param>
        </member>
        <member name="M:Nuclex.Support.Plugins.PluginRepository.AddFiles(System.String)">
            <summary>Loads all plugins matching a wildcard specification</summary>
            <param name="wildcard">Path of one or more plugins via wildcard</param>
            <remarks>
              This function always assumes that a plugin is optional. This means that
              even when you specify a unique file name and a matching file is not found,
              no exception will be raised and the error is silently ignored.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Plugins.PluginRepository.AddAssembly(System.Reflection.Assembly)">
            <summary>Adds the specified assembly to the repository</summary>
            <remarks>
              Also used internally, so any assembly that is to be put into the repository,
              not matter how, wanders through this method
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Plugins.PluginRepository.reportError(System.String)">
            <summary>Reports an error to the debugging console</summary>
            <param name="error">Error message that will be reported</param>
        </member>
        <member name="F:Nuclex.Support.Plugins.PluginRepository.assemblies">
            <summary>Loaded plugin assemblies</summary>
        </member>
        <member name="F:Nuclex.Support.Plugins.PluginRepository.assemblyLoader">
            <summary>Takes care of loading assemblies for the repositories</summary>
        </member>
        <member name="E:Nuclex.Support.Plugins.PluginRepository.AssemblyLoaded">
            <summary>Triggered whenever a new assembly is loaded into this repository</summary>
        </member>
        <member name="P:Nuclex.Support.Plugins.PluginRepository.LoadedAssemblies">
            <summary>List of all loaded plugin assemblies in the repository</summary>
        </member>
        <member name="T:Nuclex.Support.Plugins.PluginRepository.DefaultAssemblyLoader">
            <summary>Default assembly loader used to read assemblies from files</summary>
        </member>
        <member name="M:Nuclex.Support.Plugins.PluginRepository.DefaultAssemblyLoader.#ctor">
            <summary>Initializes a new default assembly loader</summary>
            <remarks>
              Made protected to provide users with a small incentive for using
              the Instance property instead of creating new instances all around.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Plugins.PluginRepository.DefaultAssemblyLoader.LoadAssemblyFromFile(System.String)">
            <summary>Loads an assembly from a file system path</summary>
            <param name="path">Path the assembly will be loaded from</param>
            <returns>The loaded assembly</returns>
        </member>
        <member name="M:Nuclex.Support.Plugins.PluginRepository.DefaultAssemblyLoader.TryLoadFile(System.String,System.Reflection.Assembly@)">
            <summary>Tries to loads an assembly from a file</summary>
            <param name="path">Path to the file that is loaded as an assembly</param>
            <param name="loadedAssembly">
              Output parameter that receives the loaded assembly or null
            </param>
            <returns>True if the assembly was loaded successfully, otherwise false</returns>
        </member>
        <member name="F:Nuclex.Support.Plugins.PluginRepository.DefaultAssemblyLoader.Instance">
            <summary>The only instance of the DefaultAssemblyLoader</summary>
        </member>
        <member name="T:Nuclex.Support.Scheduling.AbortedException">
            <summary>Indicates that an operation has been forcefully aborted</summary>
            <remarks>
              This exception is the typical result of using AsyncAbort() on a running
              background process. 
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Scheduling.AbortedException.#ctor">
            <summary>Initializes the exception</summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.AbortedException.#ctor(System.String)">
            <summary>Initializes the exception with an error message</summary>
            <param name="message">Error message describing the cause of the exception</param>
        </member>
        <member name="M:Nuclex.Support.Scheduling.AbortedException.#ctor(System.String,System.Exception)">
            <summary>Initializes the exception as a followup exception</summary>
            <param name="message">Error message describing the cause of the exception</param>
            <param name="inner">Preceding exception that has caused this exception</param>
        </member>
        <member name="T:Nuclex.Support.Scheduling.IAbortable">
            <summary>Interface for abortable processes</summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.IAbortable.AsyncAbort">
            <summary>Aborts the running process. Can be called from any thread.</summary>
            <remarks>
              The receive should honor the abort request and stop whatever it is
              doing as soon as possible. The method does not impose any requirement
              on the timeliness of the reaction of the running process, but implementers
              are advised to not ignore the abort request and urged to try and design
              their code in such a way that it can be stopped in a reasonable time
              (eg. within 1 second of the abort request).
            </remarks>
        </member>
        <member name="T:Nuclex.Support.Scheduling.Operation">
            <summary>Base class for observable operations running in the background</summary>
        </member>
        <member name="T:Nuclex.Support.Tracking.Request">
            <summary>Asynchronous request running in the background</summary>
            <remarks>
              <para>
                If the background process fails, the exception that caused it to fail is
                communicated to all parties waiting on the Request through the Join()
                method. Implementers should store any errors occuring in the asynchronous
                parts of their code in a try..catch block (or avoid throwing and just
                store a new exception) and re-throw them when in ReraiseExceptions()
              </para>
              <para>
                Like in the transaction class, the contract requires you to always call
                OnAsyncEnded(), no matter what the outcome of your operation is.
              </para>
            </remarks>
        </member>
        <member name="T:Nuclex.Support.Tracking.Transaction">
            <summary>Base class for background processes the user can wait on</summary>
            <remarks>
              <para>
                By encapsulating long-running operations which will ideally be running in
                a background thread in a class that's derived from <see cref="T:Nuclex.Support.Tracking.Transaction"/>
                you can wait for the completion of the operation and optionally even receive
                feedback on the achieved progress. This is useful for displaying a progress
                bar, loading screen or some other means of entertaining the user while he
                waits for the task to complete.
              </para>
              <para>
                You can register callbacks which will be fired once the <see cref="T:Nuclex.Support.Tracking.Transaction"/>
                task has completed. This class deliberately does not provide an Execute()
                method or anything similar to clearly seperate the initiation of an operation
                from just monitoring it. By omitting an Execute() method, it also becomes
                possible to construct a transaction just-in-time when it is explicitely being
                asked for.
              </para>
            </remarks>
        </member>
        <member name="F:Nuclex.Support.Tracking.Transaction.EndedDummy">
            <summary>A dummy transaction that's always in the 'ended' state</summary>
            <remarks>
              Useful if an operation is already complete when it's being asked for or
              when a transaction that's lazily created is accessed after the original
              operation has ended already.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Tracking.Transaction.Wait">
            <summary>Waits until the background process finishes</summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.Transaction.Wait(System.Int32)">
            <summary>Waits until the background process finishes or a timeout occurs</summary>
            <param name="timeoutMilliseconds">
              Number of milliseconds after which to stop waiting and return immediately
            </param>
            <returns>
              True if the background process completed, false if the timeout was reached
            </returns>
        </member>
        <member name="M:Nuclex.Support.Tracking.Transaction.OnAsyncEnded">
            <summary>Fires the AsyncEnded event</summary>
            <remarks>
              <para>
                This event should be fired by the implementing class when its work is completed.
                It's of no interest to this class whether the outcome of the process was
                successfull or not, the outcome and results of the process taking place both
                need to be communicated seperately.
              </para>
              <para>
                Calling this method is mandatory. Implementers need to take care that
                the OnAsyncEnded() method is called on any instance of transaction that's
                being created. This method also must not be called more than once.
              </para>
            </remarks>
        </member>
        <member name="F:Nuclex.Support.Tracking.Transaction.endedEventSubscribers">
            <summary>Event handlers which have subscribed to the ended event</summary>
            <remarks>
              Does not need to be volatile since it's only accessed inside 
            </remarks>
        </member>
        <member name="F:Nuclex.Support.Tracking.Transaction.ended">
            <summary>Whether the operation has completed yet</summary>
        </member>
        <member name="F:Nuclex.Support.Tracking.Transaction.doneEvent">
            <summary>Event that will be set when the transaction is completed</summary>
            <remarks>
              This event is will only be created when it is specifically asked for using
              the WaitHandle property.
            </remarks>
        </member>
        <member name="E:Nuclex.Support.Tracking.Transaction.AsyncEnded">
            <summary>Will be triggered when the transaction has ended</summary>
            <remarks>
              If the process is already finished when a client registers to this event,
              the registered callback will be invoked synchronously right when the
              registration takes place.
            </remarks>
        </member>
        <member name="P:Nuclex.Support.Tracking.Transaction.Ended">
            <summary>Whether the transaction has ended already</summary>
        </member>
        <member name="P:Nuclex.Support.Tracking.Transaction.WaitHandle">
            <summary>WaitHandle that can be used to wait for the transaction to end</summary>
        </member>
        <member name="T:Nuclex.Support.Tracking.Transaction.EndedDummyTransaction">
            <summary>Dummy transaction which always is in the 'ended' state</summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.Transaction.EndedDummyTransaction.#ctor">
            <summary>Initializes a new ended dummy transaction</summary>
        </member>
        <member name="F:Nuclex.Support.Tracking.Request.SucceededDummy">
            <summary>Succeeded dummy request</summary>
            <remarks>
              Use to indicate success if the request has already been completed at
              the time you are asked to perform it.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Tracking.Request.CreateFailedDummy(System.Exception)">
            <summary>Creates a new failed dummy request</summary>
            <param name="exception">Exception that supposedly caused the request to fail</param>
            <returns>
              A failed request that reports the provided exception as cause for its failure
            </returns>
        </member>
        <member name="M:Nuclex.Support.Tracking.Request.Join">
            <summary>Waits for the background operation to end</summary>
            <remarks>
              Any exceptions raised in the background operation will be thrown
              in this method. If you decide to override this method, you should
              call Wait() first (and let any possible exception through to your
              caller).
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Tracking.Request.ReraiseExceptions">
            <summary>
              Allows the specific request implementation to re-throw an exception if
              the background process finished unsuccessfully
            </summary>
        </member>
        <member name="T:Nuclex.Support.Tracking.Request.EndedDummyRequest">
            <summary>Dummy request that is always in the ended state</summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.Request.EndedDummyRequest.#ctor">
            <summary>Creates a new successfully completed dummy request</summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.Request.EndedDummyRequest.#ctor(System.Exception)">
            <summary>Creates a new failed dummy request</summary>
            <param name="exception">Exception that caused the dummy to fail</param>
        </member>
        <member name="M:Nuclex.Support.Tracking.Request.EndedDummyRequest.ReraiseExceptions">
            <summary>
              Allows the specific request implementation to re-throw an exception if
              the background process finished unsuccessfully
            </summary>
        </member>
        <member name="F:Nuclex.Support.Tracking.Request.EndedDummyRequest.exception">
            <summary>Exception that supposedly caused the request to fail</summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.Operation.Start">
            <summary>Launches the background operation</summary>
        </member>
        <member name="T:Nuclex.Support.Scheduling.OperationQueue`1">
            <summary>Operation that sequentially executes a series of operations</summary>
            <typeparam name="OperationType">
              Type of the child operations the QueueOperation will contain
            </typeparam>
        </member>
        <member name="T:Nuclex.Support.Tracking.IProgressReporter">
            <summary>Interface for processes that report their progress</summary>
        </member>
        <member name="E:Nuclex.Support.Tracking.IProgressReporter.AsyncProgressChanged">
            <summary>Triggered when the status of the process changes</summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.OperationQueue`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>Initializes a new queue operation with default weights</summary>
            <param name="childs">Child operations to execute in this operation</param>
            <remarks>
              All child operations will have a default weight of 1.0
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Scheduling.OperationQueue`1.#ctor(System.Collections.Generic.IEnumerable{Nuclex.Support.Tracking.WeightedTransaction{`0}})">
            <summary>Initializes a new queue operation with custom weights</summary>
            <param name="childs">Child operations to execute in this operation</param>
        </member>
        <member name="M:Nuclex.Support.Scheduling.OperationQueue`1.#ctor">
            <summary>Initializes a new queue operation</summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.OperationQueue`1.Start">
            <summary>Launches the background operation</summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.OperationQueue`1.ReraiseExceptions">
            <summary>
              Allows the specific request implementation to re-throw an exception if
              the background process finished unsuccessfully
            </summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.OperationQueue`1.OnAsyncProgressChanged(System.Single)">
            <summary>Fires the progress update event</summary>
            <param name="progress">Progress to report (ranging from 0.0 to 1.0)</param>
            <remarks>
              Informs the observers of this transaction about the achieved progress.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Scheduling.OperationQueue`1.OnAsyncProgressChanged(Nuclex.Support.Tracking.ProgressReportEventArgs)">
            <summary>Fires the progress update event</summary>
            <param name="eventArguments">Progress to report (ranging from 0.0 to 1.0)</param>
            <remarks>
              Informs the observers of this transaction about the achieved progress.
              Allows for classes derived from the transaction class to easily provide
              a custom event arguments class that has been derived from the
              transaction's ProgressUpdateEventArgs class.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Scheduling.OperationQueue`1.startCurrentOperation">
            <summary>Prepares the current operation and calls its Start() method</summary>
            <remarks>
              This subscribes the queue to the events of to the current operation
              and launches the operation by calling its Start() method.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Scheduling.OperationQueue`1.endCurrentOperation">
            <summary>Disconnects from the current operation and calls its End() method</summary>
            <remarks>
              This unsubscribes the queue from the current operation's events, calls End()
              on the operation and, if the operation didn't have an exception to report,
              counts up the accumulated progress of th  e queue.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Scheduling.OperationQueue`1.asyncOperationEnded(System.Object,System.EventArgs)">
            <summary>Called when the current executing operation ends</summary>
            <param name="sender">Operation that ended</param>
            <param name="arguments">Not used</param>
        </member>
        <member name="M:Nuclex.Support.Scheduling.OperationQueue`1.asyncOperationProgressChanged(System.Object,Nuclex.Support.Tracking.ProgressReportEventArgs)">
            <summary>Called when currently executing operation makes progress</summary>
            <param name="sender">Operation that has achieved progress</param>
            <param name="arguments">Not used</param>
        </member>
        <member name="F:Nuclex.Support.Scheduling.OperationQueue`1.asyncOperationEndedDelegate">
            <summary>Delegate to the asyncOperationEnded() method</summary>
        </member>
        <member name="F:Nuclex.Support.Scheduling.OperationQueue`1.asyncOperationProgressChangedDelegate">
            <summary>Delegate to the asyncOperationProgressUpdated() method</summary>
        </member>
        <member name="F:Nuclex.Support.Scheduling.OperationQueue`1.children">
            <summary>Operations being managed in the queue</summary>
        </member>
        <member name="F:Nuclex.Support.Scheduling.OperationQueue`1.totalWeight">
            <summary>Summed weight of all operations in the queue</summary>
        </member>
        <member name="F:Nuclex.Support.Scheduling.OperationQueue`1.completedWeight">
            <summary>Accumulated weight of the operations already completed</summary>
        </member>
        <member name="F:Nuclex.Support.Scheduling.OperationQueue`1.currentOperationIndex">
            <summary>Index of the operation currently executing</summary>
        </member>
        <member name="F:Nuclex.Support.Scheduling.OperationQueue`1.completionStatus">
            <summary>Used to detect when an operation completes synchronously</summary>
        </member>
        <member name="F:Nuclex.Support.Scheduling.OperationQueue`1.exception">
            <summary>Exception that has occured in the background process</summary>
        </member>
        <member name="E:Nuclex.Support.Scheduling.OperationQueue`1.AsyncProgressChanged">
            <summary>will be triggered to report when progress has been achieved</summary>
        </member>
        <member name="P:Nuclex.Support.Scheduling.OperationQueue`1.Children">
            <summary>Provides access to the child operations of this queue</summary>
        </member>
        <member name="T:Nuclex.Support.Scheduling.ThreadCallbackOperation">
            <summary>Operation that executes a method in a background thread</summary>
        </member>
        <member name="T:Nuclex.Support.Scheduling.ThreadOperation">
            <summary>Operation that executes a method in a background thread</summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.ThreadOperation.#ctor">
            <summary>
              Initializes a new threaded operation.
            </summary>
            <remarks>
              Uses a ThreadPool thread to execute the method in a background thread.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Scheduling.ThreadOperation.#ctor(System.Boolean)">
            <summary>
              Initializes a new threaded operation which optionally uses the ThreadPool.
            </summary>
            <param name="useThreadPool">Whether to use a ThreadPool thread.</param>
            <remarks>
              If useThreadPool is false, a new thread will be created. This guarantees
              that the method will be executed immediately but has an impact on
              performance since the creation of new threads is not a cheap operation.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Scheduling.ThreadOperation.Start">
            <summary>Launches the background operation</summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.ThreadOperation.Execute">
            <summary>Contains the payload to be executed in the background thread</summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.ThreadOperation.callMethod(System.Object)">
            <summary>Invokes the delegate passed as an argument</summary>
            <param name="state">Not used</param>
        </member>
        <member name="M:Nuclex.Support.Scheduling.ThreadOperation.callMethod">
            <summary>Invokes the delegate passed as an argument</summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.ThreadOperation.ReraiseExceptions">
            <summary>
              Allows the specific request implementation to re-throw an exception if
              the background process finished unsuccessfully
            </summary>
        </member>
        <member name="F:Nuclex.Support.Scheduling.ThreadOperation.useThreadPool">
            <summary>Whether to use the ThreadPool for obtaining a background thread</summary>
        </member>
        <member name="F:Nuclex.Support.Scheduling.ThreadOperation.exception">
            <summary>Exception that has occured in the background process</summary>
        </member>
        <member name="M:Nuclex.Support.Scheduling.ThreadCallbackOperation.#ctor(System.Threading.ThreadStart)">
            <summary>
              Initializes a new threaded method operation that will call back a
              parameterless method from the background thread.
            </summary>
            <param name="method">Method to be invoked in a background thread</param>
            <remarks>
              Uses a ThreadPool thread to execute the method in
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Scheduling.ThreadCallbackOperation.#ctor(System.Threading.ThreadStart,System.Boolean)">
            <summary>
              Initializes a new threaded method operation that will call back a
              parameterless method from the background thread and use the
              thread pool optionally.
            </summary>
            <param name="method">Method to be invoked in a background thread</param>
            <param name="useThreadPool">Whether to use a ThreadPool thread</param>
            <remarks>
              If useThreadPool is false, a new thread will be created. This guarantees
              that the method will be executed immediately but has an impact on
              performance since the creation of new threads is not a cheap operation.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Scheduling.ThreadCallbackOperation.Execute">
            <summary>Executes the thread callback in the background thread</summary>
        </member>
        <member name="F:Nuclex.Support.Scheduling.ThreadCallbackOperation.method">
            <summary>Method to be invoked in a background thread</summary>
        </member>
        <member name="T:Nuclex.Support.Shared`1">
            <summary>Manages a globally shared instance of the given Type</summary>
            <typeparam name="SharedType">
              Type of which a globally shared instance will be provided
            </typeparam>
        </member>
        <member name="F:Nuclex.Support.Shared`1.instance">
            <summary>Stored the globally shared instance</summary>
        </member>
        <member name="P:Nuclex.Support.Shared`1.Instance">
            <summary>Returns the global instance of the class</summary>
        </member>
        <member name="T:Nuclex.Support.IO.ChainStream">
            <summary>Chains a series of independent streams into a single stream</summary>
            <remarks>
              <para>
                This class can be used to chain multiple independent streams into a single
                stream that acts as if its chained streams were only one combined stream.
                It is useful to avoid creating huge memory streams or temporary files when
                you just need to prepend or append some data to a stream or if you need to
                read a file that was split into several parts as if it was a single file.
              </para>
              <para>
                It is not recommended to change the size of any chained stream after it
                has become part of a stream chainer, though the stream chainer will do its
                best to cope with the changes as they occur. Increasing the length of a
                chained stream is generally not an issue for streams that support seeking,
                but reducing the length might invalidate the stream chainer's file pointer,
                resulting in an IOException when Read() or Write() is next called.
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Support.IO.ChainStream.#ctor(System.IO.Stream[])">
            <summary>Initializes a new stream chainer</summary>
            <param name="streams">Array of streams that will be chained together</param>
        </member>
        <member name="M:Nuclex.Support.IO.ChainStream.Flush">
            <summary>
              Clears all buffers for this stream and causes any buffered data to be written
              to the underlying device.
            </summary>
        </member>
        <member name="M:Nuclex.Support.IO.ChainStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
              Reads a sequence of bytes from the stream and advances the position of
              the file pointer by the number of bytes read.
            </summary>
            <param name="buffer">Buffer that will receive the data read from the stream</param>
            <param name="offset">
              Offset in the buffer at which the stream will place the data read
            </param>
            <param name="count">Maximum number of bytes that will be read</param>
            <returns>
              The number of bytes that were actually read from the stream and written into
              the provided buffer
            </returns>
            <exception cref="T:System.NotSupportedException">
              The chained stream at the current position does not support reading
            </exception>
        </member>
        <member name="M:Nuclex.Support.IO.ChainStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>Changes the position of the file pointer</summary>
            <param name="offset">
              Offset to move the file pointer by, relative to the position indicated by
              the <paramref name="origin" /> parameter.
            </param>
            <param name="origin">
              Reference point relative to which the file pointer is placed
            </param>
            <returns>The new absolute position within the stream</returns>
        </member>
        <member name="M:Nuclex.Support.IO.ChainStream.SetLength(System.Int64)">
            <summary>Changes the length of the stream</summary>
            <param name="value">New length the stream shall have</param>
            <exception cref="T:System.NotSupportedException">
              Always, the stream chainer does not support the SetLength() operation
            </exception>
        </member>
        <member name="M:Nuclex.Support.IO.ChainStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
              Writes a sequence of bytes to the stream and advances the position of
              the file pointer by the number of bytes written.
            </summary>
            <param name="buffer">
              Buffer containing the data that will be written to the stream
            </param>
            <param name="offset">
              Offset in the buffer at which the data to be written starts
            </param>
            <param name="count">Number of bytes that will be written into the stream</param>
            <remarks>
              The behavior of this method is as follows: If one or more chained streams
              do not support seeking, all data is appended to the final stream in the
              chain. Otherwise, writing will begin with the stream the current file pointer
              offset falls into. If the end of that stream is reached, writing continues
              in the next stream. On the last stream, writing more data into the stream
              that it current size allows will enlarge the stream.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.IO.ChainStream.moveFilePointer(System.Int64)">
            <summary>Moves the file pointer</summary>
            <param name="position">New position the file pointer will be moved to</param>
        </member>
        <member name="M:Nuclex.Support.IO.ChainStream.findStreamIndexAndOffset(System.Int64,System.Int32@,System.Int64@)">
            <summary>
              Finds the stream index and local offset for an absolute position within
              the combined streams.
            </summary>
            <param name="overallPosition">Absolute position within the combined streams</param>
            <param name="streamIndex">
              Index of the stream the overall position falls into
            </param>
            <param name="streamPosition">
              Local position within the stream indicated by <paramref name="streamIndex" />
            </param>
        </member>
        <member name="M:Nuclex.Support.IO.ChainStream.determineCapabilities">
            <summary>Determines the capabilities of the chained streams</summary>
            <remarks>
              <para>
                Theoretically, it would be possible to create a stream chainer that supported
                writing only when the file pointer was on a chained stream with write support,
                that could seek within the beginning of the stream until the first chained
                stream with no seek capability was encountered and so on.
              </para>
              <para>
                However, the interface of the Stream class requires us to make a definitive
                statement as to whether the Stream supports seeking, reading and writing.
                We can't return "maybe" or "mostly" in CanSeek, so the only sane choice that
                doesn't violate the Stream interface is to implement these capabilities as
                all or nothing - either all streams support a feature, or the stream chainer
                will report the feature as unsupported.
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Support.IO.ChainStream.makeSeekNotSupportedException(System.String)">
            <summary>
              Constructs a NotSupportException for an error caused by one of the chained
              streams having no seek support
            </summary>
            <param name="action">Action that was tried to perform</param>
            <returns>The newly constructed NotSupportedException</returns>
        </member>
        <member name="F:Nuclex.Support.IO.ChainStream.streams">
            <summary>Streams that have been chained together</summary>
        </member>
        <member name="F:Nuclex.Support.IO.ChainStream.position">
            <summary>Current position of the overall file pointer</summary>
        </member>
        <member name="F:Nuclex.Support.IO.ChainStream.activeReadStreamIndex">
            <summary>Stream we're currently reading from if seeking is not supported</summary>
            <remarks>
              If seeking is not supported, the stream chainer will read from each stream
              until the end was reached
              sequentially
            </remarks>
        </member>
        <member name="F:Nuclex.Support.IO.ChainStream.activeReadStreamPosition">
            <summary>Position in the current read stream if seeking is not supported</summary>
            <remarks>
              If there is a mix of streams supporting seeking and not supporting seeking, we
              need to keep track of the read index for those streams that do. If, for example,
              the last stream is written to and read from in succession, the file pointer
              of that stream would have been moved to the end by the write attempt, skipping
              data that should have been read in the following read attempt.
            </remarks>
        </member>
        <member name="F:Nuclex.Support.IO.ChainStream.allStreamsCanSeek">
            <summary>Whether all of the chained streams support seeking</summary>
        </member>
        <member name="F:Nuclex.Support.IO.ChainStream.allStreamsCanRead">
            <summary>Whether all of the chained streams support reading</summary>
        </member>
        <member name="F:Nuclex.Support.IO.ChainStream.allStreamsCanWrite">
            <summary>Whether all of the chained streams support writing</summary>
        </member>
        <member name="P:Nuclex.Support.IO.ChainStream.CanRead">
            <summary>Whether data can be read from the stream</summary>
        </member>
        <member name="P:Nuclex.Support.IO.ChainStream.CanSeek">
            <summary>Whether the stream supports seeking</summary>
        </member>
        <member name="P:Nuclex.Support.IO.ChainStream.CanWrite">
            <summary>Whether data can be written into the stream</summary>
        </member>
        <member name="P:Nuclex.Support.IO.ChainStream.Length">
            <summary>Length of the stream in bytes</summary>
            <exception cref="T:System.NotSupportedException">
              At least one of the chained streams does not support seeking
            </exception>
        </member>
        <member name="P:Nuclex.Support.IO.ChainStream.Position">
            <summary>Absolute position of the file pointer within the stream</summary>
            <exception cref="T:System.NotSupportedException">
              At least one of the chained streams does not support seeking
            </exception>
        </member>
        <member name="P:Nuclex.Support.IO.ChainStream.ChainedStreams">
            <summary>Streams being combined by the stream chainer</summary>
        </member>
        <member name="T:Nuclex.Support.StringBuilderHelper">
            <summary>Contains helper methods for the string builder class</summary>
        </member>
        <member name="F:Nuclex.Support.StringBuilderHelper.numbers">
            <summary>Predefined unicode characters for the numbers 0 to 9</summary>
        </member>
        <member name="M:Nuclex.Support.StringBuilderHelper.Clear(System.Text.StringBuilder)">
            <summary>Clears the contents of a string builder</summary>
            <param name="builder">String builder that will be cleared</param>
        </member>
        <member name="M:Nuclex.Support.StringBuilderHelper.Append(System.Text.StringBuilder,System.Byte)">
            <summary>
              Appends an integer to a string builder without generating garbage
            </summary>
            <param name="builder">String builder to which an integer will be appended</param>
            <param name="value">Byte that will be appended to the string builder</param>
            <remarks>
              The normal StringBuilder.Append() method generates garbage when converting
              integer arguments whereas this method will avoid any garbage, albeit probably
              with a small performance impact compared to the built-in method.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.StringBuilderHelper.Append(System.Text.StringBuilder,System.Int32)">
            <summary>
              Appends an integer to a string builder without generating garbage
            </summary>
            <param name="builder">String builder to which an integer will be appended</param>
            <param name="value">Integer that will be appended to the string builder</param>
            <remarks>
              The normal StringBuilder.Append() method generates garbage when converting
              integer arguments whereas this method will avoid any garbage, albeit probably
              with a small performance impact compared to the built-in method.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.StringBuilderHelper.Append(System.Text.StringBuilder,System.Int64)">
            <summary>
              Appends an long integer to a string builder without generating garbage
            </summary>
            <param name="builder">String builder to which an integer will be appended</param>
            <param name="value">Long integer that will be appended to the string builder</param>
            <remarks>
              The normal StringBuilder.Append() method generates garbage when converting
              integer arguments whereas this method will avoid any garbage, albeit probably
              with a small performance impact compared to the built-in method.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.StringBuilderHelper.Append(System.Text.StringBuilder,System.Single)">
            <summary>
              Appends a floating point value to a string builder without generating garbage
            </summary>
            <param name="builder">String builder the value will be appended to</param>
            <param name="value">Value that will be appended to the string builder</param>
            <returns>Whether the value was inside the algorithm's supported range</returns>
            <remarks>
              Uses an algorithm that covers the sane range of possible values but will
              fail to render extreme values, NaNs and infinity. In these cases, false
              is returned and the traditional double.ToString() method can be used.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.StringBuilderHelper.Append(System.Text.StringBuilder,System.Single,System.Int32)">
            <summary>
              Appends a floating point value to a string builder without generating garbage
            </summary>
            <param name="builder">String builder the value will be appended to</param>
            <param name="value">Value that will be appended to the string builder</param>
            <param name="decimalPlaces">Maximum number of decimal places to display</param>
            <returns>Whether the value was inside the algorithm's supported range</returns>
            <remarks>
              Uses an algorithm that covers the sane range of possible values but will
              fail to render extreme values, NaNs and infinity. In these cases, false
              is returned and the traditional double.ToString() method can be used.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.StringBuilderHelper.Append(System.Text.StringBuilder,System.Double)">
            <summary>
              Appends a double precision floating point value to a string builder
              without generating garbage
            </summary>
            <param name="builder">String builder the value will be appended to</param>
            <param name="value">Value that will be appended to the string builder</param>
            <returns>Whether the value was inside the algorithm's supported range</returns>
            <remarks>
              Uses an algorithm that covers the sane range of possible values but will
              fail to render extreme values, NaNs and infinity. In these cases, false
              is returned and the traditional double.ToString() method can be used.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.StringBuilderHelper.Append(System.Text.StringBuilder,System.Double,System.Int32)">
            <summary>
              Appends a double precision floating point value to a string builder
              without generating garbage
            </summary>
            <param name="builder">String builder the value will be appended to</param>
            <param name="value">Value that will be appended to the string builder</param>
            <param name="decimalPlaces">Maximum number of decimal places to display</param>
            <returns>Whether the value was inside the algorithm's supported range</returns>
            <remarks>
              Uses an algorithm that covers the sane range of possible values but will
              fail to render extreme values, NaNs and infinity. In these cases, false
              is returned and the traditional double.ToString() method can be used.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.StringBuilderHelper.recursiveAppend(System.Text.StringBuilder,System.Int32)">
            <summary>Recursively appends a number's characters to a string builder</summary>
            <param name="builder">String builder the number will be appended to</param>
            <param name="remaining">Remaining digits that will be recursively processed</param>
        </member>
        <member name="M:Nuclex.Support.StringBuilderHelper.recursiveAppend(System.Text.StringBuilder,System.Int64)">
            <summary>Recursively appends a number's characters to a string builder</summary>
            <param name="builder">String builder the number will be appended to</param>
            <param name="remaining">Remaining digits that will be recursively processed</param>
        </member>
        <member name="T:Nuclex.Support.StringHelper">
            <summary>Helper routines for working with strings</summary>
        </member>
        <member name="M:Nuclex.Support.StringHelper.IndexNotOfAny(System.String,System.Char[])">
            <summary>
              Searches for the first occurence of a character other than the characters
              listed in the <paramref name="anyNotOf" /> parameter
            </summary>
            <param name="haystack">String that will be scanned in</param>
            <param name="anyNotOf">Characters to not look for in the scanned string</param>
            <returns>
              The index of the first occurence of a character not in the
              <paramref name="anyNotOf" /> array or -1 if all characters in the string were
              present in the <paramref name="anyNotOf" /> array.
            </returns>
        </member>
        <member name="M:Nuclex.Support.StringHelper.IndexNotOfAny(System.String,System.Char[],System.Int32)">
            <summary>
              Searches for the first occurence of a character other than the characters
              listed in the <paramref name="anyNotOf" /> parameter
            </summary>
            <param name="haystack">String that will be scanned in</param>
            <param name="anyNotOf">Characters to not look for in the scanned string</param>
            <param name="startIndex">
              Index of the character in the haystack at which to start scanning
            </param>
            <returns>
              The index of the first occurence of a character not in the
              <paramref name="anyNotOf" /> array or -1 if all characters in the string were
              present in the <paramref name="anyNotOf" /> array.
            </returns>
        </member>
        <member name="M:Nuclex.Support.StringHelper.IndexNotOfAny(System.String,System.Char[],System.Int32,System.Int32)">
            <summary>
              Searches for the first occurence of a character other than the characters
              listed in the <paramref name="anyNotOf" /> parameter
            </summary>
            <param name="haystack">String that will be scanned in</param>
            <param name="anyNotOf">Characters to not look for in the scanned string</param>
            <param name="startIndex">
              Index of the character in the haystack at which to start scanning
            </param>
            <param name="count">Number of characters in the haystack to scan</param>
            <returns>
              The index of the first occurence of a character not in the
              <paramref name="anyNotOf" /> array or -1 if all characters in the string were
              present in the <paramref name="anyNotOf" /> array.
            </returns>
        </member>
        <member name="M:Nuclex.Support.StringHelper.LastIndexNotOfAny(System.String,System.Char[])">
            <summary>
              Searches backwards for the first occurence of a character other than the
              characters listed in the <paramref name="anyNotOf" /> parameter
            </summary>
            <param name="haystack">String that will be scanned in</param>
            <param name="anyNotOf">Characters to not look for in the scanned string</param>
            <returns>
              The index of the first occurence of a character not in the
              <paramref name="anyNotOf" /> array or -1 if all characters in the string were
              present in the <paramref name="anyNotOf" /> array.
            </returns>
        </member>
        <member name="M:Nuclex.Support.StringHelper.LastIndexNotOfAny(System.String,System.Char[],System.Int32)">
            <summary>
              Searches backwards for the first occurence of a character other than the
              characters listed in the <paramref name="anyNotOf" /> parameter
            </summary>
            <param name="haystack">String that will be scanned in</param>
            <param name="anyNotOf">Characters to not look for in the scanned string</param>
            <param name="startIndex">
              Index of the character in the haystack at which to start scanning
            </param>
            <returns>
              The index of the first occurence of a character not in the
              <paramref name="anyNotOf" /> array or -1 if all characters in the string were
              present in the <paramref name="anyNotOf" /> array.
            </returns>
        </member>
        <member name="M:Nuclex.Support.StringHelper.LastIndexNotOfAny(System.String,System.Char[],System.Int32,System.Int32)">
            <summary>
              Searches backwards for the first occurence of a character other than the
              characters listed in the <paramref name="anyNotOf" /> parameter
            </summary>
            <param name="haystack">String that will be scanned in</param>
            <param name="anyNotOf">Characters to not look for in the scanned string</param>
            <param name="startIndex">
              Index of the character in the haystack at which to start scanning
            </param>
            <param name="count">Number of characters in the haystack to scan</param>
            <returns>
              The index of the first occurence of a character not in the
              <paramref name="anyNotOf" /> array or -1 if all characters in the string were
              present in the <paramref name="anyNotOf" /> array.
            </returns>
        </member>
        <member name="T:Nuclex.Support.StringSegment">
            <summary>Delimits a section of a string</summary>
            <remarks>
              <para>
                The design of this class pretty much mirrors that of the
                <see cref="T:System.ArraySegment" /> class found in the .NET framework, but is
                specialized to be used for strings, which can not be expressed as arrays but
                share a lot of the characteristics of an array.
              </para>
              <para>
                In certain situations, passing a StringSegment instead of the the actual
                section from a string is useful. For example, the caller might want to know
                from which index of the original string the substring was taken. Used internally
                in parsers, it can also prevent needless string copying and garbage generation.
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Support.StringSegment.#ctor(System.String)">
            <summary>
              Initializes a new instance of the <see cref="T:Nuclex.Support.StringSegment"/> class that delimits
              all the elements in the specified string
            </summary>
            <param name="text">String that will be wrapped</param>
            <exception cref="T:System.ArgumentNullException">String is null</exception>
        </member>
        <member name="M:Nuclex.Support.StringSegment.#ctor(System.String,System.Int32,System.Int32)">
            <summary>
              Initializes a new instance of the <see cref="T:Nuclex.Support.StringSegment"/> class that delimits
              the specified range of the elements in the specified string
            </summary>
            <param name="text">The string containing the range of elements to delimit</param>
            <param name="offset">The zero-based index of the first element in the range</param>
            <param name="count">The number of elements in the range</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
              Offset or count is less than 0
            </exception>
            <exception cref="T:System.ArgumentException">
              Offset and count do not specify a valid range in array
            </exception>
            <exception cref="T:System.ArgumentNullException">String is null</exception>
        </member>
        <member name="M:Nuclex.Support.StringSegment.GetHashCode">
            <summary>Returns the hash code for the current instance</summary>
            <returns>A 32-bit signed integer hash code</returns>
        </member>
        <member name="M:Nuclex.Support.StringSegment.Equals(System.Object)">
            <summary>
              Determines whether the specified object is equal to the current instance
            </summary>
            <returns>
              True if the specified object is a <see cref="T:Nuclex.Support.StringSegment"/> structure and is
              equal to the current instance; otherwise, false
            </returns>
            <param name="other">The object to be compared with the current instance</param>
        </member>
        <member name="M:Nuclex.Support.StringSegment.Equals(Nuclex.Support.StringSegment)">
            <summary>
              Determines whether the specified <see cref="T:Nuclex.Support.StringSegment"/> structure is equal
              to the current instance
            </summary>
            <returns>
              True if the specified <see cref="T:Nuclex.Support.StringSegment"/> structure is equal to the
              current instance; otherwise, false
            </returns>
            <param name="other">
              The <see cref="T:Nuclex.Support.StringSegment"/> structure to be compared with the current instance
            </param>
        </member>
        <member name="M:Nuclex.Support.StringSegment.op_Equality(Nuclex.Support.StringSegment,Nuclex.Support.StringSegment)">
            <summary>
              Indicates whether two <see cref="T:Nuclex.Support.StringSegment"/> structures are equal
            </summary>
            <returns>True if a is equal to b; otherwise, false</returns>
            <param name="left">
              The <see cref="T:Nuclex.Support.StringSegment"/> structure on the left side of the
              equality operator
            </param>
            <param name="right">
              The <see cref="T:Nuclex.Support.StringSegment"/> structure on the right side of the
              equality operator
            </param>
        </member>
        <member name="M:Nuclex.Support.StringSegment.op_Inequality(Nuclex.Support.StringSegment,Nuclex.Support.StringSegment)">
            <summary>
              Indicates whether two <see cref="T:Nuclex.Support.StringSegment"/> structures are unequal
            </summary>
            <returns>True if a is not equal to b; otherwise, false</returns>
            <param name="left">
              The <see cref="T:Nuclex.Support.StringSegment"/> structure on the left side of the
              inequality operator
            </param>
            <param name="right">
              The <see cref="T:Nuclex.Support.StringSegment"/> structure on the right side of the
              inequality operator
            </param>
        </member>
        <member name="M:Nuclex.Support.StringSegment.ToString">
            <summary>Returns a string representation of the string segment</summary>
            <returns>The string representation of the string segment</returns>
        </member>
        <member name="F:Nuclex.Support.StringSegment.text">
            <summary>String wrapped by the string segment</summary>
        </member>
        <member name="F:Nuclex.Support.StringSegment.offset">
            <summary>Offset in the original string the segment begins at</summary>
        </member>
        <member name="F:Nuclex.Support.StringSegment.count">
            <summary>Number of characters in the segment</summary>
        </member>
        <member name="P:Nuclex.Support.StringSegment.Text">
            <summary>
              Gets the original string containing the range of elements that the string
              segment delimits
            </summary>
            <returns>
              The original array that was passed to the constructor, and that contains the range
              delimited by the <see cref="T:Nuclex.Support.StringSegment"/>
            </returns>
        </member>
        <member name="P:Nuclex.Support.StringSegment.Offset">
            <summary>
              Gets the position of the first element in the range delimited by the array segment,
              relative to the start of the original array
            </summary>
            <returns>
              The position of the first element in the range delimited by the
              <see cref="T:Nuclex.Support.StringSegment"/>, relative to the start of the original array
            </returns>
        </member>
        <member name="P:Nuclex.Support.StringSegment.Count">
            <summary>
              Gets the number of elements in the range delimited by the array segment
            </summary>
            <returns>
              The number of elements in the range delimited by the <see cref="T:Nuclex.Support.StringSegment"/>
            </returns>
        </member>
        <member name="T:Nuclex.Support.Tracking.IdleStateEventArgs">
            <summary>Event arguments for an idle state change notification</summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.IdleStateEventArgs.#ctor(System.Boolean)">
            <summary>Initializes the idle state change notification</summary>
            <param name="idle">The new idle state</param>
        </member>
        <member name="F:Nuclex.Support.Tracking.IdleStateEventArgs.idle">
            <summary>Current idle state</summary>
        </member>
        <member name="P:Nuclex.Support.Tracking.IdleStateEventArgs.Idle">
            <summary>Current idle state</summary>
        </member>
        <member name="T:Nuclex.Support.Tracking.ObservedWeightedTransaction`1">
            <summary>Transaction being observed by another object</summary>
            <typeparam name="TransactionType">
              Type of the transaction that is being observed
            </typeparam>
        </member>
        <member name="M:Nuclex.Support.Tracking.ObservedWeightedTransaction`1.#ctor(Nuclex.Support.Tracking.WeightedTransaction{`0},Nuclex.Support.Tracking.ObservedWeightedTransaction{`0}.ReportDelegate,Nuclex.Support.Tracking.ObservedWeightedTransaction{`0}.ReportDelegate)">
            <summary>Initializes a new observed transaction</summary>
            <param name="weightedTransaction">Weighted transaction being observed</param>
            <param name="progressUpdateCallback">
              Callback to invoke when the transaction's progress changes
            </param>
            <param name="endedCallback">
              Callback to invoke when the transaction has ended
            </param>
        </member>
        <member name="M:Nuclex.Support.Tracking.ObservedWeightedTransaction`1.Dispose">
            <summary>Immediately releases all resources owned by the object</summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.ObservedWeightedTransaction`1.asyncEnded(System.Object,System.EventArgs)">
            <summary>Called when the observed transaction has ended</summary>
            <param name="sender">Transaction that has ended</param>
            <param name="e">Not used</param>
        </member>
        <member name="M:Nuclex.Support.Tracking.ObservedWeightedTransaction`1.asyncProgressChanged(System.Object,Nuclex.Support.Tracking.ProgressReportEventArgs)">
            <summary>Called when the progress of the observed transaction changes</summary>
            <param name="sender">Transaction whose progress has changed</param>
            <param name="arguments">Contains the updated progress</param>
        </member>
        <member name="M:Nuclex.Support.Tracking.ObservedWeightedTransaction`1.asyncDisconnectEvents">
            <summary>Unsubscribes from all events of the observed transaction</summary>
        </member>
        <member name="F:Nuclex.Support.Tracking.ObservedWeightedTransaction`1.progressReporter">
            <summary>The observed transaction's progress reporting interface</summary>
        </member>
        <member name="F:Nuclex.Support.Tracking.ObservedWeightedTransaction`1.weightedTransaction">
            <summary>The weighted wable that is being observed</summary>
        </member>
        <member name="F:Nuclex.Support.Tracking.ObservedWeightedTransaction`1.progressUpdateCallback">
            <summary>Callback to invoke when the progress updates</summary>
        </member>
        <member name="F:Nuclex.Support.Tracking.ObservedWeightedTransaction`1.endedCallback">
            <summary>Callback to invoke when the transaction ends</summary>
        </member>
        <member name="F:Nuclex.Support.Tracking.ObservedWeightedTransaction`1.progress">
            <summary>Progress achieved so far</summary>
        </member>
        <member name="P:Nuclex.Support.Tracking.ObservedWeightedTransaction`1.WeightedTransaction">
            <summary>Weighted transaction being observed</summary>
        </member>
        <member name="P:Nuclex.Support.Tracking.ObservedWeightedTransaction`1.Progress">
            <summary>Amount of progress this transaction has achieved so far</summary>
        </member>
        <member name="T:Nuclex.Support.Tracking.ObservedWeightedTransaction`1.ReportDelegate">
            <summary>Delegate for reporting progress updates</summary>
        </member>
        <member name="T:Nuclex.Support.Tracking.WeightedTransactionWrapperCollection`1">
            <summary>Collection of transactions with a weighting value</summary>
            <typeparam name="TransactionType">Type of transactions to manage</typeparam>
            <remarks>
              <para>
                This collection is exposed as a read-only collection to the user that
                stores WeightedTransactions. Internally, it merely wraps a collection of
                an internal type used to keep track of the individual transaction's
                progress in the TransactionGroup and OperationQueue classes.
              </para>
              <para>
                It is read-only because the design requires a transaction to only ever finish
                once. If it was possible eg. to add items after a TransactionGroup had signalled
                itself as being finished, it would be moved into an unfinished state again.
                Also, an empty TransactionGroup is, by definition, finished (simply because
                there is no work to do) - unless the contents of the group are passed to the
                TransactionGroup's constructor and never modified at all, the design would be
                violated as soon as an instance of the TransactionGroup or OperationQueue
                classes was created.
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Tracking.WeightedTransactionWrapperCollection`1.#ctor(System.Collections.Generic.IList{Nuclex.Support.Tracking.ObservedWeightedTransaction{`0}})">
            <summary>Initializes a new weighted transaction collection wrapper</summary>
            <param name="items">Items to be exposed as weighted transactions</param>
        </member>
        <member name="M:Nuclex.Support.Tracking.WeightedTransactionWrapperCollection`1.Transform(Nuclex.Support.Tracking.ObservedWeightedTransaction{`0})">
            <summary>Transforms an item into the exposed type</summary>
            <param name="item">Item to be transformed</param>
            <returns>The transformed item</returns>
            <remarks>
              This method is used to transform an item in the wrapped collection into
              the exposed item type whenever the user accesses an item. Expect it to
              be called frequently, because the TransformingReadOnlyCollection does
              not cache otherwise store the transformed items.
            </remarks>
        </member>
        <member name="T:Nuclex.Support.Tracking.IStatusReporter">
            <summary>Interface for processes that report their status</summary>
        </member>
        <member name="E:Nuclex.Support.Tracking.IStatusReporter.AsyncStatusChanged">
            <summary>Triggered when the status of the process changes</summary>
        </member>
        <member name="T:Nuclex.Support.Tracking.ProgressReportEventArgs">
            <summary>Event arguments for a progress update notification</summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.ProgressReportEventArgs.#ctor(System.Single)">
            <summary>Initializes the progress update informations</summary>
            <param name="progress">Achieved progress ranging from 0.0 to 1.0</param>
        </member>
        <member name="F:Nuclex.Support.Tracking.ProgressReportEventArgs.progress">
            <summary>Achieved progress</summary>
        </member>
        <member name="P:Nuclex.Support.Tracking.ProgressReportEventArgs.Progress">
            <summary>Currently achieved progress</summary>
        </member>
        <member name="T:Nuclex.Support.Tracking.ProgressTracker">
            <summary>
              Helps tracking the progress of one or more background transactions
            </summary>
            <remarks>
              <para>
                This is useful if you want to display a progress bar for multiple
                transactions but can not guarantee that no additional transactions
                will appear inmidst of execution.
              </para>
              <para>
                This class does not implement the <see cref="T:Nuclex.Support.Tracking.Transaction"/> interface itself
                in order to not violate the design principles of transactions which
                guarantee that a <see cref="T:Nuclex.Support.Tracking.Transaction"/> will only finish once (whereas the
                progress tracker might 'finish' any number of times).
              </para>
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Tracking.ProgressTracker.#ctor">
            <summary>Initializes a new transaction tracker</summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.ProgressTracker.Dispose">
            <summary>Immediately releases all resources owned by the instance</summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.ProgressTracker.Track(Nuclex.Support.Tracking.Transaction)">
            <summary>Begins tracking the specified background transactions</summary>
            <param name="transaction">Background transaction to be tracked</param>
        </member>
        <member name="M:Nuclex.Support.Tracking.ProgressTracker.Track(Nuclex.Support.Tracking.Transaction,System.Single)">
            <summary>Begins tracking the specified background transaction</summary>
            <param name="transaction">Background transaction to be tracked</param>
            <param name="weight">Weight to assign to this background transaction</param>
        </member>
        <member name="M:Nuclex.Support.Tracking.ProgressTracker.Untrack(Nuclex.Support.Tracking.Transaction)">
            <summary>Stops tracking the specified background transaction</summary>
            <param name="transaction">Background transaction to stop tracking of</param>
        </member>
        <member name="M:Nuclex.Support.Tracking.ProgressTracker.OnAsyncIdleStateChanged(System.Boolean)">
            <summary>Fires the AsyncIdleStateChanged event</summary>
            <param name="idle">New idle state to report</param>
        </member>
        <member name="M:Nuclex.Support.Tracking.ProgressTracker.OnAsyncProgressUpdated(System.Single)">
            <summary>Fires the AsyncProgressUpdated event</summary>
            <param name="progress">New progress to report</param>
        </member>
        <member name="M:Nuclex.Support.Tracking.ProgressTracker.recalculateProgress">
            <summary>Recalculates the total progress of the tracker</summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.ProgressTracker.asyncEnded">
            <summary>Called when one of the tracked transactions has ended</summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.ProgressTracker.asyncProgressChanged">
            <summary>Called when one of the tracked transactions has achieved progress</summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.ProgressTracker.setIdle(System.Boolean)">
            <summary>Changes the idle state</summary>
            <param name="idle">Whether or not the tracker is currently idle</param>
            <remarks>
              This method expects to be called during a lock() on trackedTransactions!
            </remarks>
        </member>
        <member name="F:Nuclex.Support.Tracking.ProgressTracker.idle">
            <summary>Whether the tracker is currently idle</summary>
        </member>
        <member name="F:Nuclex.Support.Tracking.ProgressTracker.progress">
            <summary>Current summed progress of the tracked transactions</summary>
        </member>
        <member name="F:Nuclex.Support.Tracking.ProgressTracker.totalWeight">
            <summary>Total weight of all transactions being tracked</summary>
        </member>
        <member name="F:Nuclex.Support.Tracking.ProgressTracker.trackedTransactions">
            <summary>Transactions being tracked by this tracker</summary>
        </member>
        <member name="F:Nuclex.Support.Tracking.ProgressTracker.asyncEndedDelegate">
            <summary>Delegate for the asyncEnded() method</summary>
        </member>
        <member name="F:Nuclex.Support.Tracking.ProgressTracker.asyncProgressUpdatedDelegate">
            <summary>Delegate for the asyncProgressUpdated() method</summary>
        </member>
        <member name="E:Nuclex.Support.Tracking.ProgressTracker.AsyncIdleStateChanged">
            <summary>Triggered when the idle state of the tracker changes</summary>
            <remarks>
              The tracker is idle when no transactions are being tracked in it. If you're
              using this class to feed a progress bar, this would be the event to use for
              showing or hiding the progress bar. The tracker starts off as idle because,
              upon construction, its list of transactions will be empty.
            </remarks>
        </member>
        <member name="E:Nuclex.Support.Tracking.ProgressTracker.AsyncProgressChanged">
            <summary>Triggered when the total progress has changed</summary>
        </member>
        <member name="P:Nuclex.Support.Tracking.ProgressTracker.Idle">
            <summary>Whether the tracker is currently idle</summary>
        </member>
        <member name="P:Nuclex.Support.Tracking.ProgressTracker.Progress">
            <summary>Current summed progress of the tracked transactions</summary>
        </member>
        <member name="T:Nuclex.Support.Tracking.ProgressTracker.TransactionMatcher">
            <summary>Matches a direct transaction to a fully wrapped one</summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.ProgressTracker.TransactionMatcher.#ctor(Nuclex.Support.Tracking.Transaction)">
            <summary>
              Initializes a new transaction matcher that matches against
              the specified transaction
            </summary>
            <param name="toMatch">Transaction to match against</param>
        </member>
        <member name="M:Nuclex.Support.Tracking.ProgressTracker.TransactionMatcher.Matches(Nuclex.Support.Tracking.ObservedWeightedTransaction{Nuclex.Support.Tracking.Transaction})">
            <summary>
              Checks whether the provided transaction matches the comparison
              transaction of the instance
            </summary>
            <param name="other">Transaction to match to the comparison transaction</param>
        </member>
        <member name="F:Nuclex.Support.Tracking.ProgressTracker.TransactionMatcher.toMatch">
            <summary>Transaction this instance compares against</summary>
        </member>
        <member name="T:Nuclex.Support.Tracking.Request`1">
            <summary>Request providing a result that can be passed to the caller</summary>
            <typeparam name="ResultType">
              Type of the result being provided by the request
            </typeparam>
        </member>
        <member name="M:Nuclex.Support.Tracking.Request`1.CreateSucceededDummy(`0)">
            <summary>Creates a new failed dummy request</summary>
            <param name="result">Result to provide to the caller</param>
            <returns>
              A succeeded request that returns the provided result to the caller
            </returns>
        </member>
        <member name="M:Nuclex.Support.Tracking.Request`1.CreateFailedDummy(System.Exception)">
            <summary>Creates a new failed dummy request</summary>
            <param name="exception">Exception that supposedly caused the request to fail</param>
            <returns>
              A failed request that reports the provided exception as cause for its failure
            </returns>
        </member>
        <member name="M:Nuclex.Support.Tracking.Request`1.Join">
            <summary>Waits for the background operation to end</summary>
            <remarks>
              Any exceptions raised in the background operation will be thrown
              in this method. If you decide to override this method, you should
              call End() first (and let any possible exception through to your
              caller).
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Tracking.Request`1.ReraiseExceptions">
            <summary>
              Allows the specific request implementation to re-throw an exception if
              the background process finished unsuccessfully
            </summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.Request`1.GatherResults">
            <summary>
              Allows the specific request to return the results of the Request to the
              caller of the Join() method
            </summary>
        </member>
        <member name="T:Nuclex.Support.Tracking.Request`1.SucceededDummyRequest">
            <summary>Succeeded dummy request that is always in the ended state</summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.Request`1.SucceededDummyRequest.#ctor(`0)">
            <summary>Creates a new failed dummy request</summary>
            <param name="result">Result to return to the request's caller</param>
        </member>
        <member name="M:Nuclex.Support.Tracking.Request`1.SucceededDummyRequest.GatherResults">
            <summary>
              Allows the specific request implementation to re-throw an exception if
              the background process finished unsuccessfully
            </summary>
        </member>
        <member name="F:Nuclex.Support.Tracking.Request`1.SucceededDummyRequest.result">
            <summary>Results the succeede dummy request will provide to the caller</summary>
        </member>
        <member name="T:Nuclex.Support.Tracking.Request`1.FailedDummyRequest">
            <summary>Failed dummy request that is always in the ended state</summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.Request`1.FailedDummyRequest.#ctor(System.Exception)">
            <summary>Creates a new failed dummy request</summary>
            <param name="exception">Exception that caused the dummy to fail</param>
        </member>
        <member name="M:Nuclex.Support.Tracking.Request`1.FailedDummyRequest.GatherResults">
            <summary>
              Allows the specific request implementation to re-throw an exception if
              the background process finished unsuccessfully
            </summary>
        </member>
        <member name="F:Nuclex.Support.Tracking.Request`1.FailedDummyRequest.exception">
            <summary>Exception that supposedly caused the request to fail</summary>
        </member>
        <member name="T:Nuclex.Support.Tracking.TransactionGroup`1">
            <summary>Forms a single transaction from a group of transactions</summary>
            <typeparam name="TransactionType">Type of transactions to manage as a set</typeparam>
        </member>
        <member name="M:Nuclex.Support.Tracking.TransactionGroup`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>Initializes a new transaction group</summary>
            <param name="children">Transactions to track with this group</param>
            <remarks>
              Uses a default weighting factor of 1.0 for all transactions.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Tracking.TransactionGroup`1.#ctor(System.Collections.Generic.IEnumerable{Nuclex.Support.Tracking.WeightedTransaction{`0}})">
            <summary>Initializes a new transaction group</summary>
            <param name="children">Transactions to track with this group</param>
        </member>
        <member name="M:Nuclex.Support.Tracking.TransactionGroup`1.Dispose">
            <summary>Immediately releases all resources owned by the object</summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.TransactionGroup`1.OnAsyncProgressChanged(System.Single)">
            <summary>Fires the progress update event</summary>
            <param name="progress">Progress to report (ranging from 0.0 to 1.0)</param>
            <remarks>
              Informs the observers of this transaction about the achieved progress.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Tracking.TransactionGroup`1.OnAsyncProgressChanged(Nuclex.Support.Tracking.ProgressReportEventArgs)">
            <summary>Fires the progress update event</summary>
            <param name="eventArguments">Progress to report (ranging from 0.0 to 1.0)</param>
            <remarks>
              Informs the observers of this transaction about the achieved progress.
              Allows for classes derived from the transaction class to easily provide
              a custom event arguments class that has been derived from the
              transaction's ProgressUpdateEventArgs class.
            </remarks>
        </member>
        <member name="M:Nuclex.Support.Tracking.TransactionGroup`1.asyncProgressUpdated">
            <summary>
              Called when the progress of one of the observed transactions changes
            </summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.TransactionGroup`1.asyncChildEnded">
            <summary>
              Called when an observed transaction ends
            </summary>
        </member>
        <member name="F:Nuclex.Support.Tracking.TransactionGroup`1.children">
            <summary>Transactions being managed in the set</summary>
        </member>
        <member name="F:Nuclex.Support.Tracking.TransactionGroup`1.wrapper">
            <summary>
              Wrapper collection for exposing the child transactions under the
              WeightedTransaction interface
            </summary>
        </member>
        <member name="F:Nuclex.Support.Tracking.TransactionGroup`1.totalWeight">
            <summary>Summed weight of all transactions in the set</summary>
        </member>
        <member name="F:Nuclex.Support.Tracking.TransactionGroup`1.endedCalled">
            <summary>Whether we already called OnAsyncEnded</summary>
        </member>
        <member name="E:Nuclex.Support.Tracking.TransactionGroup`1.AsyncProgressChanged">
            <summary>will be triggered to report when progress has been achieved</summary>
        </member>
        <member name="P:Nuclex.Support.Tracking.TransactionGroup`1.Children">
            <summary>Childs contained in the transaction set</summary>
        </member>
        <member name="T:Nuclex.Support.Tracking.StatusReportEventArgs">
            <summary>Event arguments for reporting a status to the subscriber</summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.StatusReportEventArgs.#ctor(System.String)">
            <summary>Initializes a new status report event arguments container</summary>
            <param name="status">Status to report to the event's subscribers</param>
        </member>
        <member name="F:Nuclex.Support.Tracking.StatusReportEventArgs.status">
            <summary>Reported status</summary>
        </member>
        <member name="P:Nuclex.Support.Tracking.StatusReportEventArgs.Status">
            <summary>The currently reported status</summary>
            <remarks>
              The contents of this string are up to the publisher of the event to
              define. Though it is recommended to report the status as a human-readable
              string, these strings might not in all cases be properly localized or
              suitable for display in a GUI.
            </remarks>
        </member>
        <member name="T:Nuclex.Support.Tracking.WeightedTransaction`1">
            <summary>Transaction with an associated weight for the total progress</summary>
        </member>
        <member name="M:Nuclex.Support.Tracking.WeightedTransaction`1.#ctor(`0)">
            <summary>
              Initializes a new weighted transaction with a default weight of 1.0
            </summary>
            <param name="transaction">Transaction whose progress to monitor</param>
        </member>
        <member name="M:Nuclex.Support.Tracking.WeightedTransaction`1.#ctor(`0,System.Single)">
            <summary>Initializes a new weighted transaction</summary>
            <param name="transaction">transaction whose progress to monitor</param>
            <param name="weight">Weighting of the transaction's progress</param>
        </member>
        <member name="F:Nuclex.Support.Tracking.WeightedTransaction`1.transaction">
            <summary>Transaction whose progress we're tracking</summary>
        </member>
        <member name="F:Nuclex.Support.Tracking.WeightedTransaction`1.weight">
            <summary>Weighting of this transaction in the total progress</summary>
        </member>
        <member name="P:Nuclex.Support.Tracking.WeightedTransaction`1.Transaction">
            <summary>Transaction being wrapped by this weighted transaction</summary>
        </member>
        <member name="P:Nuclex.Support.Tracking.WeightedTransaction`1.Weight">
            <summary>The contribution of this transaction to the total progress</summary>
        </member>
        <member name="T:Nuclex.Support.WeakReference`1">
            <summary>
              Type-safe weak reference, referencing an object while still allowing
              that object to be garbage collected.
            </summary>
        </member>
        <member name="M:Nuclex.Support.WeakReference`1.#ctor(`0)">
            <summary>
              Initializes a new instance of the WeakReference class, referencing
              the specified object.
            </summary>
            <param name="target">The object to track or null.</param>
        </member>
        <member name="M:Nuclex.Support.WeakReference`1.#ctor(`0,System.Boolean)">
            <summary>
              Initializes a new instance of the WeakReference class, referencing
              the specified object optionally using resurrection tracking.
            </summary>
            <param name="target">An object to track.</param>
            <param name="trackResurrection">
              Indicates when to stop tracking the object. If true, the object is tracked
              after finalization; if false, the object is only tracked until finalization.
            </param>
        </member>
        <member name="P:Nuclex.Support.WeakReference`1.Target">
            <summary>
              Gets or sets the object (the target) referenced by the current WeakReference
              object.
            </summary>
            <remarks>
              Is null if the object referenced by the current System.WeakReference object
              has been garbage collected; otherwise, a reference to the object referenced
              by the current System.WeakReference object.
            </remarks>
            <exception cref="T:System.InvalidOperationException">
              The reference to the target object is invalid. This can occur if the current
              System.WeakReference object has been finalized
            </exception>
        </member>
        <member name="T:Nuclex.Support.XmlHelper">
            <summary>Helper routines for handling XML code</summary>
        </member>
        <member name="M:Nuclex.Support.XmlHelper.LoadSchema(System.String)">
            <summary>Loads a schema from a file</summary>
            <param name="schemaPath">Path to the file containing the schema</param>
            <returns>The loaded schema</returns>
        </member>
        <member name="M:Nuclex.Support.XmlHelper.LoadSchema(System.IO.Stream)">
            <summary>Loads a schema from the provided stream</summary>
            <param name="schemaStream">Stream containing the schema that will be loaded</param>
            <returns>The loaded schema</returns>
        </member>
        <member name="M:Nuclex.Support.XmlHelper.LoadSchema(System.IO.TextReader)">
            <summary>Loads a schema from a text reader</summary>
            <param name="schemaReader">Text reader through which the schema can be read</param>
            <returns>The loaded schema</returns>
        </member>
        <member name="M:Nuclex.Support.XmlHelper.TryLoadSchema(System.String,System.Xml.Schema.XmlSchema@)">
            <summary>Attempts to load a schema from a file</summary>
            <param name="schemaPath">Path to the file containing the schema</param>
            <param name="schema">Output parameter that will receive the loaded schema</param>
            <returns>True if the schema was loaded successfully, otherwise false</returns>
        </member>
        <member name="M:Nuclex.Support.XmlHelper.TryLoadSchema(System.IO.Stream,System.Xml.Schema.XmlSchema@)">
            <summary>Attempts to load a schema from the provided stream</summary>
            <param name="schemaStream">Stream containing the schema that will be loaded</param>
            <param name="schema">Output parameter that will receive the loaded schema</param>
            <returns>True if the schema was loaded successfully, otherwise false</returns>
        </member>
        <member name="M:Nuclex.Support.XmlHelper.TryLoadSchema(System.IO.TextReader,System.Xml.Schema.XmlSchema@)">
            <summary>Attempts to load a schema from the provided text reader</summary>
            <param name="schemaReader">Reader from which the schema can be read</param>
            <param name="schema">Output parameter that will receive the loaded schema</param>
            <returns>True if the schema was loaded successfully, otherwise false</returns>
        </member>
        <member name="M:Nuclex.Support.XmlHelper.LoadDocument(System.Xml.Schema.XmlSchema,System.String)">
            <summary>Loads an XML document from a file</summary>
            <param name="schema">Schema to use for validating the XML document</param>
            <param name="documentPath">
              Path to the file containing the XML document that will be loaded
            </param>
            <returns>The loaded XML document</returns>
        </member>
        <member name="M:Nuclex.Support.XmlHelper.LoadDocument(System.Xml.Schema.XmlSchema,System.IO.Stream)">
            <summary>Loads an XML document from a stream</summary>
            <param name="schema">Schema to use for validating the XML document</param>
            <param name="documentStream">
              Stream from which the XML document will be read
            </param>
            <returns>The loaded XML document</returns>
        </member>
        <member name="M:Nuclex.Support.XmlHelper.openFileForSharedReading(System.String)">
            <summary>Opens a file for shared reading</summary>
            <param name="path">Path to the file that will be opened</param>
            <returns>The opened file's stream</returns>
        </member>
        <member name="M:Nuclex.Support.XmlHelper.tryOpenFileForSharedReading(System.String,System.IO.FileStream@)">
            <summary>Opens a file for shared reading</summary>
            <param name="path">Path to the file that will be opened</param>
            <param name="fileStream">
              Output parameter that receives the opened file's stream
            </param>
            <returns>True if the file was opened successfully</returns>
        </member>
        <member name="T:Nuclex.Support.XmlHelper.ValidationEventProcessor">
            <summary>Handles any events occurring when an XML schema is loaded</summary>
        </member>
        <member name="M:Nuclex.Support.XmlHelper.ValidationEventProcessor.OnValidationEvent(System.Object,System.Xml.Schema.ValidationEventArgs)">
            <summary>
              Callback for notifications being sent by the XmlSchema.Read() method
            </summary>
            <param name="sender">Not used</param>
            <param name="arguments">Contains the notification being sent</param>
        </member>
        <member name="F:Nuclex.Support.XmlHelper.ValidationEventProcessor.OccurredException">
            <summary>Exception that has occurred during schema loading</summary>
        </member>
    </members>
</doc>
